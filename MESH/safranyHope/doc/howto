ontozo egyszeru user space cli kod: raspberry zero 2w, debian, ads1115, device tree --> 4db talajnedvesseg mero (hestore: SMH-13-M) + 2db hordo viz folyadekszint kapcsolo (also , felso) (hestore: FSPP-090084) GPIO17,GPIO18(inputs) +  magnesszelep hestore: RELC-1CH-3V-H (GPIO27 output); Ha a talaj nedvesseg egy definialt szint ala esik, akkor a magnes szelep nyisson, ha egy adott szint folott van, akkor zarjon; a hordo az also kacsolo alatt nyomtassa a kijelzore, hogy tolteni kell, ha felso kapcsolo jelez, akkor nyomtassa azt, hogy szivaggyu kikapcsolas kell;


Szuper feladat! Itt egy **egyszer≈±, user-space CLI** Python program Raspberry Pi Zero 2 W-re (Debian), ami:

* az **ADS1x15** (ADS1115/ADS1015) IIO sysfs-en kereszt√ºl olvassa a **4 db talajnedvess√©g** csatorn√°t,
* a **hord√≥ k√©t √∫sz√≥kapcsol√≥j√°t** (GPIO17 als√≥, GPIO18 fels≈ë) GPIO-n figyeli,
* a **m√°gnesszelepet** (GPIO27) vez√©rli **hiszter√©zissel**: ha b√°rmely z√≥na a k√ºsz√∂b al√° esik ‚Üí NYIT, ha mind f√∂l√© ker√ºl ‚Üí Z√ÅR,
* a konzolra √≠rja: ‚Äû**T√ñLTENI KELL**‚Äù (als√≥ √∫sz√≥ akt√≠v) √©s ‚Äû**SZIVATTY√ö KIKAPCSOL√ÅS KELL**‚Äù (fels≈ë √∫sz√≥ akt√≠v).

> **F√ºgg≈ës√©gek:**
> `sudo apt install python3-rpi.gpio`
> (IIO m√°r megy n√°lad: `/sys/bus/iio/devices/iio:device*/in_voltage*_raw` l√°tszik.)

---

### `ontozo.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Egyszer≈± √∂nt√∂z≈ë vez√©rl≈ë ‚Äì ADS1x15 (IIO) + 2 √∫sz√≥kapcsol√≥ + m√°gnesszelep
# Pi Zero 2W / Debian
#
# GPIO kioszt√°s (BCM):
#   - Als√≥ szintkapcsol√≥: GPIO17 (bemenet)
#   - Fels≈ë szintkapcsol√≥: GPIO18 (bemenet)
#   - M√°gnesszelep rel√©:   GPIO27 (kimenet)
#
# Talajnedvess√©g: ADS1x15 IIO: in_voltage0..3_raw + in_voltage*_scale
# Hiszter√©zis: ha b√°rmely z√≥na < START_PCT  -> NYIT
#               ha minden z√≥na >= STOP_PCT  -> Z√ÅR
#
# FONTOS: A kapacit√≠v talajnedvess√©g szenzorok kimenete elt√©rhet (nedves->nagyobb V vagy ford√≠tva).
# Kalibr√°ld a WET_V √©s DRY_V √©rt√©keket a val√≥s m√©rt fesz√ºlts√©gekhez!
# Ha n√°lad ford√≠tott az ir√°ny, csak cser√©ld fel az √©rt√©keket, a k√≥d lekezeli.
#
import os, glob, time, argparse, sys
from datetime import datetime

try:
    import RPi.GPIO as GPIO
except ImportError:
    print("Hi√°nyzik a RPi.GPIO: sudo apt install python3-rpi.gpio", file=sys.stderr)
    sys.exit(1)

# ---------- FELHASZN√ÅL√ìI BE√ÅLL√çT√ÅSOK (szerkeszthet≈ë konstansok) ----------
# ADS IIO eszk√∂z automatikus keres√©se; ha tudod a fix el√©r√©si utat, √≠rd be ide:
IIO_DEVICE_PATH = None  # pl. "/sys/bus/iio/devices/iio:device0" vagy None = autodetekci√≥

# Talajnedvess√©g csatorn√°k (ADS1x15 0..3)
SOIL_CHANNELS = [0, 1, 2, 3]

# Kalibr√°ci√≥ (volt): becs√ºld meg / m√©rd ki!  WET_V = ‚Äûnagyon nedves‚Äù, DRY_V = ‚Äûnagyon sz√°raz‚Äù
# Ha n√°lad a nedvess√©ggel n≈ë a fesz√ºlts√©g, WET_V > DRY_V; ha cs√∂kken, WET_V < DRY_V.
WET_V = [2.0, 2.0, 2.0, 2.0]
DRY_V = [0.8, 0.8, 0.8, 0.8]

# Hiszter√©zis k√ºsz√∂b√∂k (%). P√©lda: 30% alatt ind√≠tson, 45% felett √°lljon le.
START_PCT = 30.0
STOP_PCT  = 45.0

# Mintav√©teli peri√≥dus (m√°sodperc)
INTERVAL_S = 5.0

# GPIO be√°ll√≠t√°sok
PIN_LOWER  = 17  # als√≥ szintkapcsol√≥ (√ºresed√©s jelz√©s)
PIN_UPPER  = 18  # fels≈ë szintkapcsol√≥ (tele hord√≥ jelz√©s)
PIN_RELAY  = 27  # m√°gnesszelep rel√©

# √ösz√≥k logik√°ja: legt√∂bb esetben a kapcsol√≥ GND-re h√∫z z√°r√°skor -> PUD_UP + "akt√≠v alacsony".
LOWER_ACTIVE_LOW = True   # True: z√°rt (LOW) = akt√≠v
UPPER_ACTIVE_LOW = True

# Rel√© logika: egyes modulok "akt√≠v alacsonyak". √Åll√≠tsd ennek megfelel≈ëen.
RELAY_ACTIVE_HIGH = True  # True: HIGH = bekapcsolt rel√©; False: LOW = bekapcsolt rel√©
# -------------------------------------------------------------------------


def autodetect_iio_device():
    for d in sorted(glob.glob("/sys/bus/iio/devices/iio:device*")):
        try:
            name = open(os.path.join(d, "name"), "r", encoding="utf-8").read().strip().lower()
        except Exception:
            continue
        if any(k in name for k in ["ads1115", "ads1015", "ti-ads1015"]):
            return d
    # ha nem tal√°lt n√©v alapj√°n, de csak egy iio:device van, haszn√°ljuk azt
    devs = sorted(glob.glob("/sys/bus/iio/devices/iio:device*"))
    return devs[0] if devs else None


def read_ads_channel(iio_dev, ch):
    raw_path   = os.path.join(iio_dev, f"in_voltage{ch}_raw")
    scale_path = os.path.join(iio_dev, f"in_voltage{ch}_scale")
    with open(raw_path, "r") as f:
        raw = int(f.read().strip())
    with open(scale_path, "r") as f:
        scale = float(f.read().strip())
    volts = raw * scale
    return raw, volts


def v_to_percent(v, wet_v, dry_v):
    # Lek√©pezz√ºk 0..100%-ra, b√°rmely ir√°nyt kezelve.
    if wet_v == dry_v:
        return 0.0
    lo, hi = (dry_v, wet_v) if dry_v < wet_v else (wet_v, dry_v)
    # norm√°l ir√°ny: dry->0%, wet->100%
    pct = 100.0 * (v - dry_v) / (wet_v - dry_v)
    # hat√°rok k√∂z√© szor√≠t√°s
    return max(0.0, min(100.0, pct))


def setup_gpio():
    GPIO.setmode(GPIO.BCM)
    GPIO.setwarnings(False)
    GPIO.setup(PIN_LOWER, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    GPIO.setup(PIN_UPPER, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    initial = GPIO.HIGH if (RELAY_ACTIVE_HIGH is False) else GPIO.LOW  # kezdetben "kikapcsolt"
    # magyar√°zat: ha akt√≠v HIGH a rel√©, a kikapcsolt szint legyen LOW; ha akt√≠v LOW, legyen HIGH
    GPIO.setup(PIN_RELAY, GPIO.OUT, initial=initial)


def is_active(pin, active_low=True):
    level = GPIO.input(pin)
    return (level == GPIO.LOW) if active_low else (level == GPIO.HIGH)


def set_relay(on: bool):
    if RELAY_ACTIVE_HIGH:
        GPIO.output(PIN_RELAY, GPIO.HIGH if on else GPIO.LOW)
    else:
        GPIO.output(PIN_RELAY, GPIO.LOW if on else GPIO.HIGH)


def main():
    parser = argparse.ArgumentParser(description="Egyszer≈± √∂nt√∂z≈ë vez√©rl≈ë ‚Äì ADS1x15 + GPIO")
    parser.add_argument("--start", type=float, default=START_PCT, help="Ind√≠t√°si k√ºsz√∂b (%%) ‚Äì ez al√° esve NYIT")
    parser.add_argument("--stop",  type=float, default=STOP_PCT,  help="Le√°ll√≠t√°si k√ºsz√∂b (%%) ‚Äì mind f√∂l√© √©rve Z√ÅR")
    parser.add_argument("--dt",    type=float, default=INTERVAL_S, help="Mintav√©teli peri√≥dus (s)")
    parser.add_argument("--iio",   type=str,   default=IIO_DEVICE_PATH, help="IIO eszk√∂z el√©r√©si √∫tja (ha √ºres, autodetekci√≥)")
    parser.add_argument("--oneshot", action="store_true", help="Egyszeri kiolvas√°s √©s kil√©p√©s (nem vez√©rel rel√©t).")
    args = parser.parse_args()

    iio_dev = args.iio or autodetect_iio_device()
    if not iio_dev or not os.path.isdir(iio_dev):
        print("Nem tal√°lom az ADS IIO eszk√∂zt. Ellen≈ërizd, hogy az ADS1x15 driver √©s overlay akt√≠v!", file=sys.stderr)
        sys.exit(2)

    setup_gpio()
    watering = False

    try:
        while True:
            ts = datetime.now().strftime("%H:%M:%S")
            volts = []
            pcts  = []
            for idx, ch in enumerate(SOIL_CHANNELS):
                raw, v = read_ads_channel(iio_dev, ch)
                volts.append(v)
                pct = v_to_percent(v, WET_V[idx], DRY_V[idx])
                pcts.append(pct)
            lower_active = is_active(PIN_LOWER, LOWER_ACTIVE_LOW)
            upper_active = is_active(PIN_UPPER, UPPER_ACTIVE_LOW)

            # Konzol kimenet
            zones = " | ".join([f"Z{z}:{pcts[z]:5.1f}% ({volts[z]:.3f}V)" for z in range(len(SOIL_CHANNELS))])
            msgs = []
            if lower_active:
                msgs.append("HORD√ì: T√ñLTENI KELL")
            if upper_active:
                msgs.append("HORD√ì: SZIVATTY√ö KIKAPCSOL√ÅS KELL")
            msg_str = (" ; ".join(msgs)) if msgs else "-"

            # Vez√©rl√©s (hiszter√©zis)
            any_below = any(p < args.start for p in pcts)
            all_above = all(p >= args.stop for p in pcts)

            if not args.oneshot:
                if (not watering) and any_below:
                    watering = True
                    set_relay(True)
                elif watering and all_above:
                    watering = False
                    set_relay(False)

            state = "NYITVA" if watering else "Z√ÅRVA"
            print(f"[{ts}] {zones}  |  SZELEP: {state}  |  {msg_str}")

            if args.oneshot:
                break
            time.sleep(args.dt)

    except KeyboardInterrupt:
        pass
    finally:
        set_relay(False)  # biztons√°gb√≥l z√°rjuk
        GPIO.cleanup()


if __name__ == "__main__":
    main()
```

---

### Haszn√°lat

1. M√°sold f√°jlba √©s futtathat√≥v√°:

```bash
nano ontozo.py
chmod +x ontozo.py
```

2. Futtat√°s (rootk√©nt aj√°nlott, hogy legyen GPIO hozz√°f√©r√©sed):

```bash
sudo ./ontozo.py
```

3. Opcion√°lis param√©terek:

* Egyszeri m√©r√©s (rel√© n√©lk√ºl): `sudo ./ontozo.py --oneshot`
* K√ºsz√∂b√∂k √°ll√≠t√°sa: `sudo ./ontozo.py --start 30 --stop 45`
* Id≈ëk√∂z: `sudo ./ontozo.py --dt 5`

4. **Kalibr√°ci√≥**
   Sz√°raz talaj ‚Äì m√©rd a fesz√ºlts√©get (pl. `--oneshot`), √≠rd be a z√≥n√°hoz a `DRY_V`-be.
   V√≠zbe dugott/er≈ësen nedves talaj ‚Äì √≠rd be a `WET_V`-be.
   Ha azt l√°tod, hogy nedvesed√©sre cs√∂kken a fesz√ºlts√©g, **cser√©ld fel** a k√©t √©rt√©ket (a k√≥d automatikusan kezeli az ir√°nyt, csak a sk√°l√°t add meg j√≥l).

5. **√ösz√≥kapcsol√≥k huzaloz√°s**
   Tipikusan: egyik l√°b **GND**, m√°sik **GPIO** (bels≈ë **PUD\_UP** akt√≠v). Z√°r√°skor a GPIO **LOW** ‚Üí ez√©rt `*_ACTIVE_LOW=True`. Ha n√°lad ford√≠tott, √°ll√≠tsd `False`-ra.

6. **Rel√© logika**
   Ha a rel√©modulod **akt√≠v LOW**, tedd `RELAY_ACTIVE_HIGH = False`-ra.

---

Ha k√©red, adok hozz√° **systemd szolg√°ltat√°s** egys√©gf√°jlt is, vagy csin√°lok **napl√≥f√°jlos** verzi√≥t √©s egyszer≈± CSV-logot a m√©r√©sekr≈ël.


nagyon jo! orulok! de miert preferalod a python-t? en a c++ kodot jobban szeretnem, lehet?


√ârthet≈ë üëç ha ink√°bb **C++**-ban szeretn√©d, meg tudjuk csin√°lni!
√ân Python-t aj√°nlottam el≈ësz√∂r, mert:

* Raspberry Pi-n a **GPIO √©s IIO f√°jlkezel√©s** gyorsan megoldhat√≥ Pythonban.
* Fejleszt√©si sebess√©g szempontj√°b√≥l egyszer≈±bb (gyors protot√≠pus).
* Sok p√©lda √©s k√∂nyvt√°r van hozz√° (pl. RPi.GPIO).

De **C++-ban ugyan√∫gy** lehet ‚Äì √©s Debian konzol programk√©nt m√©g ‚Äúnat√≠vabb‚Äù √©rz√©st ad.
√ân azt javaslom: **felhaszn√°l√≥i t√©rben, sysfs f√°jlok √©s GPIO chardev interf√©sz** haszn√°lat√°val.

---

### P√©lda C++ k√≥d (egyszer≈± CLI, ugyanazt csin√°lja mint a Python)

```cpp
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <chrono>
#include <thread>
#include <csignal>
#include <filesystem>
#include <gpiod.h>   // libgpiod-dev kell
using namespace std;

static bool running = true;
void sigint_handler(int) { running = false; }

// ---------- Be√°ll√≠t√°sok ----------
const vector<int> SOIL_CHANNELS = {0,1,2,3};   // ADS1115 ch0..3
const vector<double> WET_V  = {2.0,2.0,2.0,2.0};
const vector<double> DRY_V  = {0.8,0.8,0.8,0.8};

const double START_PCT = 30.0;
const double STOP_PCT  = 45.0;
const double INTERVAL_S = 5.0;

// GPIO kioszt√°s (BCM)
const int PIN_LOWER  = 17;
const int PIN_UPPER  = 18;
const int PIN_RELAY  = 27;

const bool LOWER_ACTIVE_LOW = true;
const bool UPPER_ACTIVE_LOW = true;
const bool RELAY_ACTIVE_HIGH = true;
// ---------------------------------

string autodetect_iio() {
    namespace fs = std::filesystem;
    for (auto &d : fs::directory_iterator("/sys/bus/iio/devices")) {
        string path = d.path();
        ifstream f(path + "/name");
        string name;
        if (f && getline(f,name)) {
            for (auto &c : name) c = tolower(c);
            if (name.find("ads1115")!=string::npos || name.find("ads1015")!=string::npos)
                return path;
        }
    }
    // fallback: els≈ë iio device
    for (auto &d : fs::directory_iterator("/sys/bus/iio/devices"))
        return d.path();
    return "";
}

pair<int,double> read_ads_channel(const string &iio_dev, int ch) {
    string raw_path   = iio_dev + "/in_voltage" + to_string(ch) + "_raw";
    string scale_path = iio_dev + "/in_voltage" + to_string(ch) + "_scale";
    int raw=0; double scale=0;
    ifstream f1(raw_path); f1>>raw;
    ifstream f2(scale_path); f2>>scale;
    return {raw, raw*scale};
}

double v_to_percent(double v, double wet, double dry) {
    if (wet==dry) return 0;
    double pct = 100.0 * (v-dry)/(wet-dry);
    if (pct<0) pct=0; if (pct>100) pct=100;
    return pct;
}

bool is_active(gpiod_line *line, bool active_low=true) {
    int val = gpiod_line_get_value(line);
    if (val<0) return false;
    return active_low ? (val==0) : (val==1);
}

void set_relay(gpiod_line *line, bool on) {
    if (RELAY_ACTIVE_HIGH)
        gpiod_line_set_value(line, on?1:0);
    else
        gpiod_line_set_value(line, on?0:1);
}

int main() {
    signal(SIGINT, sigint_handler);

    string iio_dev = autodetect_iio();
    if (iio_dev.empty()) {
        cerr<<"Nem tal√°lom az ADS1115 IIO eszk√∂zt"<<endl;
        return 1;
    }

    // libgpiod inicializ√°l√°s
    gpiod_chip *chip = gpiod_chip_open_by_number(0); // gpiochip0
    if (!chip) { cerr<<"Nem ny√≠lik meg gpiochip0"<<endl; return 2; }

    gpiod_line *lower = gpiod_chip_get_line(chip, PIN_LOWER);
    gpiod_line *upper = gpiod_chip_get_line(chip, PIN_UPPER);
    gpiod_line *relay = gpiod_chip_get_line(chip, PIN_RELAY);

    gpiod_line_request_input(lower, "ontozo");
    gpiod_line_request_input(upper, "ontozo");
    gpiod_line_request_output(relay, "ontozo", RELAY_ACTIVE_HIGH?0:1); // kezdetben kikapcs

    bool watering=false;

    while(running) {
        vector<double> volts, pcts;
        for (size_t i=0;i<SOIL_CHANNELS.size();++i) {
            auto [raw,v] = read_ads_channel(iio_dev, SOIL_CHANNELS[i]);
            volts.push_back(v);
            pcts.push_back(v_to_percent(v, WET_V[i], DRY_V[i]));
        }

        bool lower_act = is_active(lower, LOWER_ACTIVE_LOW);
        bool upper_act = is_active(upper, UPPER_ACTIVE_LOW);

        bool any_below=false, all_above=true;
        for (double p:pcts) {
            if (p<START_PCT) any_below=true;
            if (p<STOP_PCT) all_above=false;
        }

        if (!watering && any_below) {
            watering=true; set_relay(relay,true);
        } else if (watering && all_above) {
            watering=false; set_relay(relay,false);
        }

        cout<<"["<<time(nullptr)<<"] ";
        for (size_t i=0;i<pcts.size();++i)
            cout<<"Z"<<i<<":"<<pcts[i]<<"%("<<volts[i]<<"V) ";
        cout<<"| SZELEP:"<<(watering?"NYITVA":"ZARVA")<<" | ";
        if (lower_act) cout<<"T√ñLTENI KELL ";
        if (upper_act) cout<<"SZIVATTY√ö KIKAPCSOL√ÅS KELL";
        cout<<endl;

        this_thread::sleep_for(chrono::milliseconds(int(INTERVAL_S*1000)));
    }

    set_relay(relay,false);
    gpiod_chip_close(chip);
    return 0;
}
```

---

### Ford√≠t√°s

Debian alatt kell a **libgpiod-dev**:

```bash
sudo apt install g++ libgpiod-dev
g++ -std=c++17 ontozo.cpp -o ontozo
```

Futtat√°s rootk√©nt:

```bash
sudo ./ontozo
```

---

üëâ Ez a C++ verzi√≥ ugyanazt csin√°lja mint a Python, csak kicsit alacsonyabb szinten, √©s a **libgpiod** API-t haszn√°lja a GPIO-hoz (a r√©gi `/sys/class/gpio` m√°r deprecated).
Az **ADS1115** √©rt√©keket sysfs f√°jlon kereszt√ºl olvassa ki.

---

Szeretn√©d, hogy adjak hozz√° egy **systemd unit f√°jlt** is (hogy automatikusan induljon), vagy el≈ësz√∂r csak a C++ k√≥d tesztel√©s√©t pr√≥b√°lod ki?




jo lenne, ha csak orankent kb 10 meresbol atlagot csinalna, meresek kozott a hatterben aludna, log fajlt keszitene naponta egyet csv-t


Szuper √∂tlet. K√©sz√≠tettem egy C++ verzi√≥t, ami **√≥r√°nk√©nt** kb. **10 m√©r√©sb≈ël √°tlagol**, a m√©r√©sek k√∂z√∂tt **alszik**, √©s **naponk√©nt k√ºl√∂n CSV logf√°jlt** √≠r. A vez√©rl√©s (szelep nyit/z√°r) az **√≥r√°s √°tlag** alapj√°n d√∂nt, de a **fels≈ë √∫sz√≥** riaszt√°sa azonnal fel√ºl√≠r (azaz r√∂gt√∂n z√°r).

---

# ontozo\_hourly.cpp

```cpp
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <chrono>
#include <thread>
#include <csignal>
#include <filesystem>
#include <iomanip>
#include <ctime>
#include <gpiod.h>   // sudo apt install libgpiod-dev

using namespace std;
namespace fs = std::filesystem;

static bool running = true;
void sigint_handler(int){ running = false; }

// ======= BE√ÅLL√çT√ÅSOK (ig√©ny szerint m√≥dos√≠that√≥k) =========================
const vector<int> SOIL_CHANNELS = {0,1,2,3};   // ADS1115 ch0..3

// Kalibr√°ci√≥ (Volt): WET_V = ‚Äûnagyon nedves‚Äù, DRY_V = ‚Äûnagyon sz√°raz‚Äù.
// Ha n√°lad ford√≠tott az ir√°ny (nedvesed√©sre cs√∂kken a fesz), cser√©ld fel az √©rt√©keket.
const vector<double> WET_V = {2.0,2.0,2.0,2.0};
const vector<double> DRY_V = {0.8,0.8,0.8,0.8};

// Hiszter√©zis k√ºsz√∂b√∂k (%): START_PCT alatt ind√≠t, STOP_PCT felett √°ll le (√°tlag alapj√°n).
const double START_PCT = 30.0;
const double STOP_PCT  = 45.0;

// √ìr√°nk√©nt ennyi mint√°t gy≈±jt√ºnk -> ezek √°tlaga alapj√°n d√∂nt√ºnk (10 -> ~6 percenk√©nti m√©r√©s)
const int    SAMPLES_PER_HOUR = 10;

// GPIO kioszt√°s (BCM)
const int PIN_LOWER  = 17;   // als√≥ √∫sz√≥ (ha akt√≠v: T√ñLTENI KELL)
const int PIN_UPPER  = 18;   // fels≈ë √∫sz√≥ (ha akt√≠v: SZIVATTY√ö KIKAPCSOL√ÅS KELL -> azonnali Z√ÅR)
const int PIN_RELAY  = 27;   // m√°gnesszelep rel√©

// √ösz√≥k kapcsol√°si logik√°ja (legt√∂bbsz√∂r GND-re h√∫znak z√°r√°skor -> akt√≠v alacsony)
const bool LOWER_ACTIVE_LOW = true;
const bool UPPER_ACTIVE_LOW = true;

// Rel√© logika: ha a modul akt√≠v LOW, √°ll√≠tsd false-ra
const bool RELAY_ACTIVE_HIGH = true;

// Log k√∂nyvt√°r (naponk√©nt √∫j csv): pl. /home/pi/ontozo/logs
const string LOG_DIR = "/home/pi/ontozo/logs";
// ========================================================================


string autodetect_iio() {
    for (auto &d : fs::directory_iterator("/sys/bus/iio/devices")) {
        string path = d.path();
        ifstream f(path + "/name");
        string name;
        if (f && getline(f,name)) {
            for (auto &c : name) c = tolower(c);
            if (name.find("ads1115")!=string::npos || name.find("ads1015")!=string::npos)
                return path;
        }
    }
    // fallback: els≈ë iio device
    for (auto &d : fs::directory_iterator("/sys/bus/iio/devices"))
        return d.path();
    return "";
}

pair<int,double> read_ads_channel(const string &iio_dev, int ch) {
    string raw_path   = iio_dev + "/in_voltage" + to_string(ch) + "_raw";
    string scale_path = iio_dev + "/in_voltage" + to_string(ch) + "_scale";
    int raw=0; double scale=0;
    ifstream f1(raw_path); f1>>raw;
    ifstream f2(scale_path); f2>>scale;
    return {raw, raw*scale};
}

double v_to_percent(double v, double wet, double dry) {
    if (wet==dry) return 0.0;
    double pct = 100.0 * (v - dry) / (wet - dry); // kezeli az ir√°nyt is
    if (pct < 0.0) pct = 0.0;
    if (pct > 100.0) pct = 100.0;
    return pct;
}

bool is_active(gpiod_line *line, bool active_low=true) {
    int val = gpiod_line_get_value(line);
    if (val < 0) return false; // hiba -> ne jelezz akt√≠vnak
    return active_low ? (val==0) : (val==1);
}

void set_relay(gpiod_line *line, bool on) {
    if (RELAY_ACTIVE_HIGH)
        gpiod_line_set_value(line, on?1:0);
    else
        gpiod_line_set_value(line, on?0:1);
}

string date_str(const std::tm &tm) {
    char buf[16];
    strftime(buf, sizeof(buf), "%Y-%m-%d", &tm);
    return string(buf);
}

string time_str(const std::tm &tm) {
    char buf[16];
    strftime(buf, sizeof(buf), "%H:%M:%S", &tm);
    return string(buf);
}

ofstream open_daily_log(const string &dir, const std::tm &tm) {
    fs::create_directories(dir);
    string fname = dir + "/" + date_str(tm) + "_ontozo.csv";
    bool new_file = !fs::exists(fname);
    ofstream ofs(fname, ios::app);
    if (!ofs) {
        cerr << "Nem tudom nyitni a logot: " << fname << endl;
        return ofs;
    }
    if (new_file) {
        // fejl√©c: time, z0_v, z0_pct, z1_v, z1_pct, ..., lower, upper, valve
        ofs << "time";
        for (size_t i=0;i<SOIL_CHANNELS.size();++i) {
            ofs << ",Z" << i << "_V" << ",Z" << i << "_pct";
        }
        ofs << ",lower_active,upper_active,valve_state\n";
        ofs.flush();
    }
    return ofs;
}

int main() {
    signal(SIGINT, sigint_handler);
    signal(SIGTERM, sigint_handler);

    string iio_dev = autodetect_iio();
    if (iio_dev.empty()) {
        cerr<<"Nem tal√°lom az ADS1115 IIO eszk√∂zt.\n";
        return 1;
    }

    // libgpiod inicializ√°l√°s
    gpiod_chip *chip = gpiod_chip_open_by_number(0); // gpiochip0
    if (!chip) { cerr<<"Nem ny√≠lik meg gpiochip0\n"; return 2; }

    gpiod_line *lower = gpiod_chip_get_line(chip, PIN_LOWER);
    gpiod_line *upper = gpiod_chip_get_line(chip, PIN_UPPER);
    gpiod_line *relay = gpiod_chip_get_line(chip, PIN_RELAY);

    if (gpiod_line_request_input(lower, "ontozo") < 0 ||
        gpiod_line_request_input(upper, "ontozo") < 0) {
        cerr << "GPIO input request hiba\n";
        return 3;
    }
    // kezdetben kikapcsolt rel√©
    if (gpiod_line_request_output(relay, "ontozo", RELAY_ACTIVE_HIGH?0:1) < 0) {
        cerr << "GPIO output request hiba\n";
        return 4;
    }

    bool watering = false;                 // aktu√°lis szelep√°llapot
    const int sleep_ms = int(3600.0 / SAMPLES_PER_HOUR * 1000.0); // k√©t minta k√∂z√∂tt

    // napl√≥ megnyit√°sa
    auto now = chrono::system_clock::now();
    time_t tt = chrono::system_clock::to_time_t(now);
    std::tm tm_now = *std::localtime(&tt);
    string current_day = date_str(tm_now);
    ofstream log = open_daily_log(LOG_DIR, tm_now);

    // √ìr√°nk√©nti ciklus: folyamatosan gy≈±jt√ºnk SAMPLES_PER_HOUR mint√°t,
    // a v√©g√©n √°tlagsz√°m√≠t√°s -> d√∂nt√©s -> log-sor
    vector<vector<double>> volts_acc(SOIL_CHANNELS.size(), vector<double>());
    vector<vector<double>> pct_acc  (SOIL_CHANNELS.size(), vector<double>());

    int sample_in_hour = 0;

    while (running) {
        // √∫j nap eset√©n v√°ltunk f√°jlt
        now = chrono::system_clock::now();
        tt = chrono::system_clock::to_time_t(now);
        tm_now = *std::localtime(&tt);
        string day = date_str(tm_now);
        if (day != current_day) {
            if (log.is_open()) log.close();
            log = open_daily_log(LOG_DIR, tm_now);
            current_day = day;
        }

        // 1) mintav√©tel
        vector<double> volts, pcts;
        for (size_t i=0;i<SOIL_CHANNELS.size();++i) {
            auto [raw, v] = read_ads_channel(iio_dev, SOIL_CHANNELS[i]);
            volts.push_back(v);
            pcts.push_back(v_to_percent(v, WET_V[i], DRY_V[i]));
            volts_acc[i].push_back(v);
            pct_acc[i].push_back(pcts[i]);
        }

        bool lower_act = is_active(lower, LOWER_ACTIVE_LOW);
        bool upper_act = is_active(upper, UPPER_ACTIVE_LOW);

        // 2) biztons√°gi azonnali z√°r√°s fels≈ë √∫sz√≥ra
        if (upper_act && watering) {
            watering = false;
            set_relay(relay, false);
        }

        sample_in_hour++;

        // 3) ha megvan az √≥r√°s adag (pl. 10 minta) -> √°tlagol√°s + hiszter√©zises d√∂nt√©s
        if (sample_in_hour >= SAMPLES_PER_HOUR) {
            // √°tlag %
            vector<double> avg_pct(SOIL_CHANNELS.size(), 0.0);
            vector<double> avg_v  (SOIL_CHANNELS.size(), 0.0);
            for (size_t i=0;i<SOIL_CHANNELS.size();++i) {
                double sumv=0, sump=0;
                for (double x : volts_acc[i]) sumv += x;
                for (double x : pct_acc[i])   sump += x;
                avg_v[i]   = sumv / max<size_t>(1, volts_acc[i].size());
                avg_pct[i] = sump / max<size_t>(1, pct_acc[i].size());
            }

            // vez√©rl√©s (hiszter√©zis) ‚Äì √≥r√°s √°tlag alapj√°n
            bool any_below=false, all_above=true;
            for (double p : avg_pct) {
                if (p < START_PCT) any_below = true;
                if (p < STOP_PCT)  all_above = false;
            }
            if (!watering && any_below && !upper_act) { // fels≈ë √∫sz√≥ akt√≠v mellett ne nyissunk
                watering = true;
                set_relay(relay, true);
            } else if (watering && all_above) {
                watering = false;
                set_relay(relay, false);
            }

            // 4) napl√≥: √≥r√°s sor (id≈ë + z√≥na √°tlagok + √∫sz√≥k + szelep)
            if (log) {
                log << time_str(tm_now);
                for (size_t i=0;i<SOIL_CHANNELS.size();++i) {
                    log << "," << fixed << setprecision(3) << avg_v[i]
                        << "," << fixed << setprecision(1) << avg_pct[i];
                }
                log << "," << (lower_act?1:0)
                    << "," << (upper_act?1:0)
                    << "," << (watering?1:0)
                    << "\n";
                log.flush();
            }

            // reset a k√∂vetkez≈ë √≥r√°ra
            for (auto &v : volts_acc) v.clear();
            for (auto &v : pct_acc)   v.clear();
            sample_in_hour = 0;
        }

        // 5) alv√°s a k√∂vetkez≈ë mint√°ig
        // ha k√∂zel le√°ll√≠t√°s (SIGINT/SIGTERM), r√∂vid√≠tve √©bred√ºnk
        for (int i=0;i<sleep_ms/100; ++i) {
            if (!running) break;
            this_thread::sleep_for(chrono::milliseconds(100));
        }
    }

    // kil√©p√©s el≈ëtt szelep z√°r
    set_relay(relay, false);
    gpiod_chip_close(chip);
    if (log.is_open()) log.close();
    return 0;
}
```

---

## Ford√≠t√°s √©s futtat√°s

Telep√≠tsd a f√ºgg≈ës√©get, ford√≠tsd le:

```bash
sudo apt update
sudo apt install -y g++ libgpiod-dev
g++ -std=c++17 ontozo_hourly.cpp -o ontozo_hourly
```

Aj√°nlott saj√°t mappa √©s log k√∂nyvt√°r:

```bash
mkdir -p ~/ontozo/logs
mv ontozo_hourly ~/ontozo/
```

Futtat√°s (GPIO miatt rootk√©nt):

```bash
sudo ~/ontozo/ontozo_hourly
```

A logok itt lesznek (alapb√≥l):
`/home/pi/ontozo/logs/2025-08-26_ontozo.csv` stb. (d√°tum szerint).
Fejl√©c:
`time,Z0_V,Z0_pct,Z1_V,Z1_pct,Z2_V,Z2_pct,Z3_V,Z3_pct,lower_active,upper_active,valve_state`

---

## Opcion√°lis: systemd szolg√°ltat√°s

`/etc/systemd/system/ontozo.service`:

```ini
[Unit]
Description=Ontozo vezerlo (ADS1115 + libgpiod, orankenti atlagolas)
After=network.target

[Service]
Type=simple
User=pi
Group=pi
ExecStart=/home/pi/ontozo/ontozo_hourly
Restart=always
RestartSec=5
# GPIO-hoz lehet, hogy root kell. Ha igen:
# User=root
# Group=root

[Install]
WantedBy=multi-user.target
```

Majd:

```bash
sudo systemctl daemon-reload
sudo systemctl enable --now ontozo.service
sudo systemctl status ontozo.service
```

Ha root kell a GPIO-hoz, √°ll√≠tsd a szolg√°ltat√°sban `User=root`-ra.
(Ha szeretn√©d, adhatok egy **udev+gpio** jogosults√°g-vari√°nst is, hogy ne kelljen root.)

---

## Finomhangol√°s tippek

* **Mintasz√°m/s≈±r≈±s√©g:** `SAMPLES_PER_HOUR` n√∂vel√©s√©vel sim√°bb √°tlag, de t√∂bb √©breszt√©s.
* **K√ºsz√∂b√∂k:** `START_PCT`, `STOP_PCT` finomhangolja a hiszter√©zist.
* **Kalibr√°ci√≥:** t√∂ltsd ki a saj√°t `WET_V` / `DRY_V` √©rt√©keidet csatorn√°nk√©nt a szenzoraid alapj√°n.
* **Azonnali v√©szle√°ll√°s:** fels≈ë √∫sz√≥ akt√≠v ‚Üí azonnali szelepz√°r, f√ºggetlen√ºl az √°tlagt√≥l.

Ha szeretn√©d, csin√°lok **parancssori opci√≥s** verzi√≥t (pl. `--log-dir`, `--samples-per-hour`, `--start`, `--stop`), vagy kieg√©sz√≠tem **CSV-ben a nyers RAW** √©rt√©kekkel is.




