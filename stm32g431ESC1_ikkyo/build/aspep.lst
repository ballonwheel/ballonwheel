ARM GAS  /tmp/ccJS0l1g.s 			page 1


   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 2
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"aspep.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.ASPEP_start,"ax",%progbits
  18              		.align	1
  19              		.p2align 2,,3
  20              		.global	ASPEP_start
  21              		.arch armv7e-m
  22              		.syntax unified
  23              		.thumb
  24              		.thumb_func
  25              		.fpu fpv4-sp-d16
  27              	ASPEP_start:
  28              	.LVL0:
  29              	.LFB1439:
  30              		.file 1 "Src/aspep.c"
   1:Src/aspep.c   **** 
   2:Src/aspep.c   **** /**
   3:Src/aspep.c   ****   ******************************************************************************
   4:Src/aspep.c   ****   * @file   aspep.c
   5:Src/aspep.c   ****   * @author Motor Control SDK Team, ST Microelectronics
   6:Src/aspep.c   ****   * @brief  This file provides firmware functions that implement the aspep protocol
   7:Src/aspep.c   ****   *
   8:Src/aspep.c   ****   *
   9:Src/aspep.c   ****   ******************************************************************************
  10:Src/aspep.c   ****   * @attention
  11:Src/aspep.c   ****   *
  12:Src/aspep.c   ****   * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
  13:Src/aspep.c   ****   * All rights reserved.</center></h2>
  14:Src/aspep.c   ****   *
  15:Src/aspep.c   ****   * This software component is licensed by ST under Ultimate Liberty license
  16:Src/aspep.c   ****   * SLA0044, the "License"; You may not use this file except in compliance with
  17:Src/aspep.c   ****   * the License. You may obtain a copy of the License at:
  18:Src/aspep.c   ****   *                             www.st.com/SLA0044
  19:Src/aspep.c   ****   *
  20:Src/aspep.c   ****   ******************************************************************************
  21:Src/aspep.c   ****   */
  22:Src/aspep.c   **** 
  23:Src/aspep.c   **** #include <stdint.h>
  24:Src/aspep.c   **** #include "aspep.h"
  25:Src/aspep.c   **** 
  26:Src/aspep.c   **** /* Local definition */
  27:Src/aspep.c   **** #define MIN(a,b) ( ((a) < (b)) ? (a) : (b) )
  28:Src/aspep.c   **** 
ARM GAS  /tmp/ccJS0l1g.s 			page 2


  29:Src/aspep.c   **** /* Local functions */
  30:Src/aspep.c   **** static bool ASPEP_CheckBeacon (ASPEP_Handle_t *pHandle);
  31:Src/aspep.c   **** static uint8_t ASPEP_TXframeProcess(ASPEP_Handle_t *pHandle, uint8_t packetType, void *txBuffer, ui
  32:Src/aspep.c   **** void ASPEP_sendBeacon(ASPEP_Handle_t *pHandle, ASPEP_Capabilities_def *capabilities);
  33:Src/aspep.c   **** void ASPEP_sendPing(ASPEP_Handle_t *pHandle, uint8_t state, uint16_t PacketNumber);
  34:Src/aspep.c   **** 
  35:Src/aspep.c   **** /** @addtogroup MCSDK
  36:Src/aspep.c   ****   * @{
  37:Src/aspep.c   ****   */
  38:Src/aspep.c   **** 
  39:Src/aspep.c   **** /** @addtogroup MCP
  40:Src/aspep.c   ****   * @{
  41:Src/aspep.c   ****   */
  42:Src/aspep.c   **** 
  43:Src/aspep.c   **** #ifndef CRC4_PER_NIBBLE
  44:Src/aspep.c   **** /**
  45:Src/aspep.c   ****   * @brief CRC-4 lookup table with 256 entries
  46:Src/aspep.c   ****   *
  47:Src/aspep.c   ****   * Computes and checks the CRC on the header with the BYTE granularity.
  48:Src/aspep.c   ****   *
  49:Src/aspep.c   ****   * When computing the CRC, the 7th nibble must to be processed with the CRC_Lookup4
  50:Src/aspep.c   ****   * table. Indeed, the header contains 7 nibbles (28 bits) of data on which the CRC is
  51:Src/aspep.c   ****   * to be computed. Hence, the CRC4_Lookup8 table cannot be used for the last nibble.
  52:Src/aspep.c   ****   *
  53:Src/aspep.c   ****   * Using only this lookup table requires that the amount of input data is a multiple of
  54:Src/aspep.c   ****   * 8 bits.
  55:Src/aspep.c   ****   */
  56:Src/aspep.c   **** static uint8_t const CRC4_Lookup8[] =
  57:Src/aspep.c   **** {
  58:Src/aspep.c   ****   /*          0,    1,    2,    3,    4,    5,    6,    7,    8,    9,   A,     B,    C,    D,    E
  59:Src/aspep.c   ****   /* 0 */  0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x07, 0x05, 0x03, 0x01, 0x0f, 0x0d, 0x0b
  60:Src/aspep.c   ****   /* 1 */  0x07, 0x05, 0x03, 0x01, 0x0f, 0x0d, 0x0b, 0x09, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c
  61:Src/aspep.c   ****   /* 2 */  0x0e, 0x0c, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x00, 0x09, 0x0b, 0x0d, 0x0f, 0x01, 0x03, 0x05
  62:Src/aspep.c   ****   /* 3 */  0x09, 0x0b, 0x0d, 0x0f, 0x01, 0x03, 0x05, 0x07, 0x0e, 0x0c, 0x0a, 0x08, 0x06, 0x04, 0x02
  63:Src/aspep.c   ****   /* 4 */  0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05, 0x0c, 0x0e, 0x08, 0x0a, 0x04, 0x06, 0x00
  64:Src/aspep.c   ****   /* 5 */  0x0c, 0x0e, 0x08, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07
  65:Src/aspep.c   ****   /* 6 */  0x05, 0x07, 0x01, 0x03, 0x0d, 0x0f, 0x09, 0x0b, 0x02, 0x00, 0x06, 0x04, 0x0a, 0x08, 0x0e
  66:Src/aspep.c   ****   /* 7 */  0x02, 0x00, 0x06, 0x04, 0x0a, 0x08, 0x0e, 0x0c, 0x05, 0x07, 0x01, 0x03, 0x0d, 0x0f, 0x09
  67:Src/aspep.c   ****   /* 8 */  0x01, 0x03, 0x05, 0x07, 0x09, 0x0b, 0x0d, 0x0f, 0x06, 0x04, 0x02, 0x00, 0x0e, 0x0c, 0x0a
  68:Src/aspep.c   ****   /* 9 */  0x06, 0x04, 0x02, 0x00, 0x0e, 0x0c, 0x0a, 0x08, 0x01, 0x03, 0x05, 0x07, 0x09, 0x0b, 0x0d
  69:Src/aspep.c   ****   /* A */  0x0f, 0x0d, 0x0b, 0x09, 0x07, 0x05, 0x03, 0x01, 0x08, 0x0a, 0x0c, 0x0e, 0x00, 0x02, 0x04
  70:Src/aspep.c   ****   /* B */  0x08, 0x0a, 0x0c, 0x0e, 0x00, 0x02, 0x04, 0x06, 0x0f, 0x0d, 0x0b, 0x09, 0x07, 0x05, 0x03
  71:Src/aspep.c   ****   /* C */  0x0a, 0x08, 0x0e, 0x0c, 0x02, 0x00, 0x06, 0x04, 0x0d, 0x0f, 0x09, 0x0b, 0x05, 0x07, 0x01
  72:Src/aspep.c   ****   /* D */  0x0d, 0x0f, 0x09, 0x0b, 0x05, 0x07, 0x01, 0x03, 0x0a, 0x08, 0x0e, 0x0c, 0x02, 0x00, 0x06
  73:Src/aspep.c   ****   /* E */  0x04, 0x06, 0x00, 0x02, 0x0c, 0x0e, 0x08, 0x0a, 0x03, 0x01, 0x07, 0x05, 0x0b, 0x09, 0x0f
  74:Src/aspep.c   ****   /* F */  0x03, 0x01, 0x07, 0x05, 0x0b, 0x09, 0x0f, 0x0d, 0x04, 0x06, 0x00, 0x02, 0x0c, 0x0e, 0x08
  75:Src/aspep.c   **** };
  76:Src/aspep.c   **** 
  77:Src/aspep.c   **** /**
  78:Src/aspep.c   ****   * @brief CRC-4 lookup table with 16 entries
  79:Src/aspep.c   ****   *
  80:Src/aspep.c   ****   *  Used to compute and check the CRC on the header with either the BYTE or NIBBLE granularity
  81:Src/aspep.c   ****   * In case the BYTE granularity is used, the table is used only with the 7th nibble of the header
  82:Src/aspep.c   ****   * (bits 24 to 27) when computing the CRC.
  83:Src/aspep.c   ****   */
  84:Src/aspep.c   ****   //cstat !MISRAC2012-Rule-8.9_a
  85:Src/aspep.c   **** static uint8_t const CRC4_Lookup4[] =
ARM GAS  /tmp/ccJS0l1g.s 			page 3


  86:Src/aspep.c   **** {
  87:Src/aspep.c   ****   /*   0,    1,    2,    3,    4,    5,    6,    7,    8,    9,   A,     B,    C,    D,    E,    F 
  88:Src/aspep.c   ****   0x00, 0x07, 0x0e, 0x09, 0x0b, 0x0c, 0x05, 0x02, 0x01, 0x06, 0x0f, 0x08, 0x0a, 0x0d, 0x04, 0x03
  89:Src/aspep.c   **** };
  90:Src/aspep.c   **** #endif /* CRC4_PER_NIBBLE */
  91:Src/aspep.c   **** 
  92:Src/aspep.c   **** /**
  93:Src/aspep.c   ****   * @brief Computes a 4-bit CRC on the 28 LSBs of @p header and returns it in the 4 MSB of the head
  94:Src/aspep.c   ****   *
  95:Src/aspep.c   ****   *  The generator polynomial used for the CRC is x^4+x+1 (ref. CCITT-G704).
  96:Src/aspep.c   ****   *
  97:Src/aspep.c   ****   *  The 28 input bits are split into 7 nibbles that are processed from the least significant to th
  98:Src/aspep.c   ****   * most significant one as follows:
  99:Src/aspep.c   ****   *
 100:Src/aspep.c   ****   *  - the least significant (4-bit) nibble is processed first as if it were the most significant p
 101:Src/aspep.c   ****   *    of the divident;
 102:Src/aspep.c   ****   *  - the order of bits in each nibble is unchanged for processing which would leads to the follow
 103:Src/aspep.c   ****   *    bit processing sequence: 3, 2, 1, 0, 7, 6, 5, 4, 11, 10, 9, 8, 15, 14, 13, 12, 19, 18, 17, 1
 104:Src/aspep.c   ****   *    23, 22, 21, 20, 27, 26, 25, 24.
 105:Src/aspep.c   ****   *
 106:Src/aspep.c   ****   *  Two lookup tables based implementations are proposed: one solely relying on a 16 entries looku
 107:Src/aspep.c   ****   * table and another one that also uses a 256 entries lookup table. This last one is the default. 
 108:Src/aspep.c   ****   * requires 256 more bytes than the first but is also roughly two times faster.
 109:Src/aspep.c   ****   *
 110:Src/aspep.c   ****   *  The 16 entries lookup table based implementation is enabled when the CRC4_PER_NIBBLE preproces
 111:Src/aspep.c   ****   * flag is defined.
 112:Src/aspep.c   ****   *
 113:Src/aspep.c   ****   *  Note that the default, 256 entries lookup table based implementation also uses the 16 entries 
 114:Src/aspep.c   ****   * table because the amount of input data is not a multiple of 8 bits.
 115:Src/aspep.c   ****   *
 116:Src/aspep.c   ****   * The resulting CRC is written in bits 28 to 31 of @p header and the whole header is returned.
 117:Src/aspep.c   ****   */
 118:Src/aspep.c   **** static void ASPEP_ComputeHeaderCRC(uint32_t *headerPtr)
 119:Src/aspep.c   **** {
 120:Src/aspep.c   ****   uint8_t crc = 0;
 121:Src/aspep.c   ****   uint32_t header = *headerPtr;
 122:Src/aspep.c   **** 
 123:Src/aspep.c   **** #ifndef CRC4_PER_NIBBLE
 124:Src/aspep.c   ****   header &= 0x0fffffffU;
 125:Src/aspep.c   **** 
 126:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 127:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 128:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 129:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 130:Src/aspep.c   **** #else /* CRC4_PER_NIBBLE */
 131:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)(header         & 0xfU)];
 132:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >>  4U) & 0xfU)];
 133:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >>  8U) & 0xfU)];
 134:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 12U) & 0xfU)];
 135:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 16U) & 0xfU)];
 136:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 20U) & 0xfU)];
 137:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0xfU)];
 138:Src/aspep.c   **** #endif /* CRC4_PER_NIBBLE */
 139:Src/aspep.c   **** 
 140:Src/aspep.c   ****   *headerPtr |= (uint32_t)crc << 28;
 141:Src/aspep.c   **** 
 142:Src/aspep.c   **** }
ARM GAS  /tmp/ccJS0l1g.s 			page 4


 143:Src/aspep.c   **** 
 144:Src/aspep.c   **** /**
 145:Src/aspep.c   ****   * @brief Checks if @p header contains a valid 4-bit CRC and return true if this is the case and f
 146:Src/aspep.c   ****   *
 147:Src/aspep.c   ****   *  The CRC is computed over the 32 bits of the @p header. If the result is 0, the CRC is consider
 148:Src/aspep.c   ****   * and true is returned. If the result is not 0, false is returned.
 149:Src/aspep.c   ****   *
 150:Src/aspep.c   ****   * @sa ASPEP_ComputeHeaderCRC
 151:Src/aspep.c   ****   */
 152:Src/aspep.c   **** static bool ASPEP_CheckHeaderCRC(uint32_t header)
 153:Src/aspep.c   **** {
 154:Src/aspep.c   ****   uint8_t crc = 0;
 155:Src/aspep.c   **** 
 156:Src/aspep.c   **** #ifndef CRC4_PER_NIBBLE
 157:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 158:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 159:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 160:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 24U) & 0xffU)];
 161:Src/aspep.c   **** #else /* CRC4_PER_NIBBLE */
 162:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)(header         & 0xfU)];
 163:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >>  4U) & 0xfU)];
 164:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >>  8U) & 0xfU)];
 165:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 12U) & 0xfU)];
 166:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 16U) & 0xfU)];
 167:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 20U) & 0xfU)];
 168:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0xfU)];
 169:Src/aspep.c   ****   crc = crc ^ (uint8_t)((header >> 28) & 0xf);
 170:Src/aspep.c   **** #endif /* CRC4_PER_NIBBLE */
 171:Src/aspep.c   **** 
 172:Src/aspep.c   ****   return (crc == 0U);
 173:Src/aspep.c   **** }
 174:Src/aspep.c   **** 
 175:Src/aspep.c   **** /**
 176:Src/aspep.c   ****   * @brief  Starts ASPEP communication by configuring UART.
 177:Src/aspep.c   ****   *
 178:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 179:Src/aspep.c   ****   */
 180:Src/aspep.c   **** void ASPEP_start(ASPEP_Handle_t *pHandle)
 181:Src/aspep.c   **** {
  31              		.loc 1 181 1 view -0
  32              		.cfi_startproc
  33              		@ args = 0, pretend = 0, frame = 0
  34              		@ frame_needed = 0, uses_anonymous_args = 0
 182:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 183:Src/aspep.c   ****   if (MC_NULL == pHandle)
 184:Src/aspep.c   ****   {
 185:Src/aspep.c   ****     /* Nothing to do */
 186:Src/aspep.c   ****   }
 187:Src/aspep.c   ****   else
 188:Src/aspep.c   ****   {
 189:Src/aspep.c   **** #endif
 190:Src/aspep.c   ****     pHandle->fASPEP_HWInit(pHandle->ASPEPIp);
  35              		.loc 1 190 5 view .LVU1
 181:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
  36              		.loc 1 181 1 is_stmt 0 view .LVU2
  37 0000 10B5     		push	{r4, lr}
  38              	.LCFI0:
ARM GAS  /tmp/ccJS0l1g.s 			page 5


  39              		.cfi_def_cfa_offset 8
  40              		.cfi_offset 4, -8
  41              		.cfi_offset 14, -4
  42              		.loc 1 190 5 view .LVU3
  43 0002 C36C     		ldr	r3, [r0, #76]
 181:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
  44              		.loc 1 181 1 view .LVU4
  45 0004 0446     		mov	r4, r0
  46              		.loc 1 190 5 view .LVU5
  47 0006 4069     		ldr	r0, [r0, #20]
  48              	.LVL1:
  49              		.loc 1 190 5 view .LVU6
  50 0008 9847     		blx	r3
  51              	.LVL2:
 191:Src/aspep.c   ****     pHandle->ASPEP_State = ASPEP_IDLE;
  52              		.loc 1 191 5 is_stmt 1 view .LVU7
 192:Src/aspep.c   ****     pHandle->ASPEP_TL_State = WAITING_PACKET;
  53              		.loc 1 192 5 view .LVU8
 191:Src/aspep.c   ****     pHandle->ASPEP_State = ASPEP_IDLE;
  54              		.loc 1 191 26 is_stmt 0 view .LVU9
  55 000a 0023     		movs	r3, #0
  56 000c A4F86430 		strh	r3, [r4, #100]	@ movhi
 193:Src/aspep.c   ****     pHandle->syncPacketCount = 0; /* Sync packet counter is reset only at startup*/
  57              		.loc 1 193 5 is_stmt 1 view .LVU10
  58              		.loc 1 193 30 is_stmt 0 view .LVU11
  59 0010 84F86030 		strb	r3, [r4, #96]
 194:Src/aspep.c   ****     /* Configure UART to receive first packet*/
 195:Src/aspep.c   ****     pHandle->fASPEP_cfg_recept(pHandle->ASPEPIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
  60              		.loc 1 195 5 is_stmt 1 view .LVU12
  61 0014 6069     		ldr	r0, [r4, #20]
  62 0016 636D     		ldr	r3, [r4, #84]
  63 0018 04F11C01 		add	r1, r4, #28
  64 001c 0422     		movs	r2, #4
 196:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 197:Src/aspep.c   ****   }
 198:Src/aspep.c   **** #endif
 199:Src/aspep.c   **** }
  65              		.loc 1 199 1 is_stmt 0 view .LVU13
  66 001e BDE81040 		pop	{r4, lr}
  67              	.LCFI1:
  68              		.cfi_restore 14
  69              		.cfi_restore 4
  70              		.cfi_def_cfa_offset 0
  71              	.LVL3:
 195:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
  72              		.loc 1 195 5 view .LVU14
  73 0022 1847     		bx	r3	@ indirect register sibling call
  74              	.LVL4:
 195:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
  75              		.loc 1 195 5 view .LVU15
  76              		.cfi_endproc
  77              	.LFE1439:
  79              		.section	.text.ASPEP_sendBeacon,"ax",%progbits
  80              		.align	1
  81              		.p2align 2,,3
  82              		.global	ASPEP_sendBeacon
  83              		.syntax unified
ARM GAS  /tmp/ccJS0l1g.s 			page 6


  84              		.thumb
  85              		.thumb_func
  86              		.fpu fpv4-sp-d16
  88              	ASPEP_sendBeacon:
  89              	.LVL5:
  90              	.LFB1440:
 200:Src/aspep.c   **** 
 201:Src/aspep.c   **** /**
 202:Src/aspep.c   ****   * @brief  Sends BEACON to controller containing matched capabilities between controller and perfo
 203:Src/aspep.c   ****   *
 204:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 205:Src/aspep.c   ****   * @param  *capabilities Matched capabilities between controller and performer
 206:Src/aspep.c   ****   */
 207:Src/aspep.c   **** void ASPEP_sendBeacon(ASPEP_Handle_t *pHandle, ASPEP_Capabilities_def *capabilities)
 208:Src/aspep.c   **** {
  91              		.loc 1 208 1 is_stmt 1 view -0
  92              		.cfi_startproc
  93              		@ args = 0, pretend = 0, frame = 0
  94              		@ frame_needed = 0, uses_anonymous_args = 0
  95              		@ link register save eliminated.
 209:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 210:Src/aspep.c   ****   if ((MC_NULL == pHandle) || (NULL == capabilities))
 211:Src/aspep.c   ****   {
 212:Src/aspep.c   ****     /* Nothing to do */
 213:Src/aspep.c   ****   }
 214:Src/aspep.c   ****   else
 215:Src/aspep.c   ****   {
 216:Src/aspep.c   **** #endif
 217:Src/aspep.c   ****     uint32_t *packet = (uint32_t *)pHandle->ctrlBuffer.buffer; //cstat !MISRAC2012-Rule-11.3
  96              		.loc 1 217 5 view .LVU17
 208:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
  97              		.loc 1 208 1 is_stmt 0 view .LVU18
  98 0000 30B4     		push	{r4, r5}
  99              	.LCFI2:
 100              		.cfi_def_cfa_offset 8
 101              		.cfi_offset 4, -8
 102              		.cfi_offset 5, -4
 218:Src/aspep.c   ****     *packet = (BEACON
 219:Src/aspep.c   ****              | (((uint32_t)capabilities->version) << 4U)
 220:Src/aspep.c   ****              | (((uint32_t)capabilities->DATA_CRC) << 7U)
 103              		.loc 1 220 18 view .LVU19
 104 0002 0A78     		ldrb	r2, [r1]	@ zero_extendqisi2
 219:Src/aspep.c   ****              | (((uint32_t)capabilities->DATA_CRC) << 7U)
 105              		.loc 1 219 18 view .LVU20
 106 0004 0D79     		ldrb	r5, [r1, #4]	@ zero_extendqisi2
 221:Src/aspep.c   ****              | (((uint32_t)capabilities->RX_maxSize) << 8U)
 107              		.loc 1 221 18 view .LVU21
 108 0006 4B78     		ldrb	r3, [r1, #1]	@ zero_extendqisi2
 109              	.LBB44:
 110              	.LBB45:
 111              	.LBB46:
 112              	.LBB47:
 126:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 113              		.loc 1 126 7 view .LVU22
 114 0008 1E4C     		ldr	r4, .L9
 115              	.LBE47:
 116              	.LBE46:
ARM GAS  /tmp/ccJS0l1g.s 			page 7


 117              	.LBE45:
 118              	.LBE44:
 220:Src/aspep.c   ****              | (((uint32_t)capabilities->RX_maxSize) << 8U)
 119              		.loc 1 220 52 view .LVU23
 120 000a D201     		lsls	r2, r2, #7
 222:Src/aspep.c   ****              | (((uint32_t)capabilities->TXS_maxSize) << 14U)
 223:Src/aspep.c   ****              | (((uint32_t)capabilities->TXA_maxSize) << 21U));
 121              		.loc 1 223 14 view .LVU24
 122 000c 42EA0512 		orr	r2, r2, r5, lsl #4
 222:Src/aspep.c   ****              | (((uint32_t)capabilities->TXS_maxSize) << 14U)
 123              		.loc 1 222 18 view .LVU25
 124 0010 8D78     		ldrb	r5, [r1, #2]	@ zero_extendqisi2
 125              		.loc 1 223 18 view .LVU26
 126 0012 C978     		ldrb	r1, [r1, #3]	@ zero_extendqisi2
 127              	.LVL6:
 128              		.loc 1 223 14 view .LVU27
 129 0014 42EA0323 		orr	r3, r2, r3, lsl #8
 130 0018 43EA8533 		orr	r3, r3, r5, lsl #14
 131 001c 43EA4153 		orr	r3, r3, r1, lsl #21
 132              	.LBB62:
 133              	.LBB58:
 134              	.LBB50:
 135              	.LBB48:
 126:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 136              		.loc 1 126 26 view .LVU28
 137 0020 D9B2     		uxtb	r1, r3
 138 0022 41F00501 		orr	r1, r1, #5
 124:Src/aspep.c   **** 
 139              		.loc 1 124 10 view .LVU29
 140 0026 23F07042 		bic	r2, r3, #-268435456
 127:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 141              		.loc 1 127 26 view .LVU30
 142 002a 615C     		ldrb	r1, [r4, r1]	@ zero_extendqisi2
 129:Src/aspep.c   **** #else /* CRC4_PER_NIBBLE */
 143              		.loc 1 129 7 view .LVU31
 144 002c 164D     		ldr	r5, .L9+4
 124:Src/aspep.c   **** 
 145              		.loc 1 124 10 view .LVU32
 146 002e 42F00502 		orr	r2, r2, #5
 127:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 147              		.loc 1 127 26 view .LVU33
 148 0032 81EA1221 		eor	r1, r1, r2, lsr #8
 149 0036 C9B2     		uxtb	r1, r1
 150              	.LVL7:
 127:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 151              		.loc 1 127 26 view .LVU34
 152              	.LBE48:
 153              	.LBE50:
 154              	.LBE58:
 155              	.LBE62:
 218:Src/aspep.c   ****              | (((uint32_t)capabilities->version) << 4U)
 156              		.loc 1 218 5 is_stmt 1 view .LVU35
 224:Src/aspep.c   **** 
 225:Src/aspep.c   ****     (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 157              		.loc 1 225 5 view .LVU36
 158              	.LBB63:
 159              	.LBI44:
ARM GAS  /tmp/ccJS0l1g.s 			page 8


 226:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 227:Src/aspep.c   ****   }
 228:Src/aspep.c   **** #endif
 229:Src/aspep.c   **** }
 230:Src/aspep.c   **** 
 231:Src/aspep.c   **** /**
 232:Src/aspep.c   ****   * @brief  Sends back to controller a NOT_ACKNOWLEDGED message.
 233:Src/aspep.c   ****   *
 234:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 235:Src/aspep.c   ****   * @param  errorInfo Information on the encountered error
 236:Src/aspep.c   ****   */
 237:Src/aspep.c   **** static void ASPEP_sendNack(ASPEP_Handle_t *pHandle, uint8_t errorInfo)
 238:Src/aspep.c   **** {
 239:Src/aspep.c   ****   uint32_t *packet = (uint32_t *)pHandle->ctrlBuffer.buffer; //cstat !MISRAC2012-Rule-11.3
 240:Src/aspep.c   ****   *packet = NACK | (uint32_t)(((uint32_t) errorInfo) << 8U) | (uint32_t)(((uint32_t) errorInfo) << 
 241:Src/aspep.c   ****   (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 242:Src/aspep.c   **** }
 243:Src/aspep.c   **** 
 244:Src/aspep.c   **** /**
 245:Src/aspep.c   ****   * @brief  Sends back ping to controller once connection has been established.
 246:Src/aspep.c   ****   *
 247:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 248:Src/aspep.c   ****   * @param  cBit Set to 1 if Performer has not been reset during communication
 249:Src/aspep.c   ****   * @param  packetNumber Number of requested packet incremented throughout the entire communication
 250:Src/aspep.c   ****   */
 251:Src/aspep.c   **** void ASPEP_sendPing(ASPEP_Handle_t *pHandle, uint8_t cBit, uint16_t packetNumber)
 252:Src/aspep.c   **** {
 253:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 254:Src/aspep.c   ****   if (MC_NULL == pHandle)
 255:Src/aspep.c   ****   {
 256:Src/aspep.c   ****     /* Nothing to do */
 257:Src/aspep.c   ****   }
 258:Src/aspep.c   ****   else
 259:Src/aspep.c   ****   {
 260:Src/aspep.c   **** #endif
 261:Src/aspep.c   ****     uint32_t *packet = (uint32_t *)pHandle->ctrlBuffer.buffer; //cstat !MISRAC2012-Rule-11.3
 262:Src/aspep.c   ****     uint8_t Nbit = pHandle->syncPacketCount & 0x1U; /* Keep only LSB */
 263:Src/aspep.c   ****     uint8_t ipID = pHandle->liid & 0xFU;
 264:Src/aspep.c   ****     *packet = PING | (uint32_t)((uint32_t)cBit << 4U)
 265:Src/aspep.c   ****                    | (uint32_t)((uint32_t)cBit << 5U)
 266:Src/aspep.c   ****                    | (uint32_t)((uint32_t)Nbit << 6U)
 267:Src/aspep.c   ****                    | (uint32_t)((uint32_t)Nbit << 7U)
 268:Src/aspep.c   ****                    | (uint32_t)((uint32_t)ipID << 8U)
 269:Src/aspep.c   ****                    | (uint32_t)(((uint32_t) packetNumber) << 12U);
 270:Src/aspep.c   ****     (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 271:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 272:Src/aspep.c   ****   }
 273:Src/aspep.c   **** #endif
 274:Src/aspep.c   **** }
 275:Src/aspep.c   **** 
 276:Src/aspep.c   **** /**
 277:Src/aspep.c   ****   * @brief  Assigns new buffer depending on buffer type request and prevents overwriting.
 278:Src/aspep.c   ****   *
 279:Src/aspep.c   ****   * @param  *pSupHandle Handler of the current instance of the MCTL component
 280:Src/aspep.c   ****   * @param  **buffer Pointer to the buffer to be assigned
 281:Src/aspep.c   ****   * @param  syncAsync Type of requested buffer, can be synchronous or asynchronous
 282:Src/aspep.c   ****   *
ARM GAS  /tmp/ccJS0l1g.s 			page 9


 283:Src/aspep.c   ****   * @return Returns true if there is a writable buffer. False otherwise.
 284:Src/aspep.c   ****   */
 285:Src/aspep.c   **** bool ASPEP_getBuffer(MCTL_Handle_t *pSupHandle, void **buffer,  uint8_t syncAsync)
 286:Src/aspep.c   **** {
 287:Src/aspep.c   ****   bool result = true;
 288:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 289:Src/aspep.c   ****   if (MC_NULL == buffer)
 290:Src/aspep.c   ****   {
 291:Src/aspep.c   ****     result = false;
 292:Src/aspep.c   ****   }
 293:Src/aspep.c   ****   else
 294:Src/aspep.c   ****   {
 295:Src/aspep.c   **** #endif
 296:Src/aspep.c   ****     ASPEP_Handle_t *pHandle = (ASPEP_Handle_t *)pSupHandle; //cstat !MISRAC2012-Rule-11.3
 297:Src/aspep.c   **** 
 298:Src/aspep.c   ****     if (MCTL_SYNC == syncAsync)
 299:Src/aspep.c   ****     {
 300:Src/aspep.c   ****       if (pHandle->syncBuffer.state <= writeLock) /* Possible values are free or writeLock*/
 301:Src/aspep.c   ****       {
 302:Src/aspep.c   ****         *buffer = &pHandle->syncBuffer.buffer[ASPEP_HEADER_SIZE];
 303:Src/aspep.c   ****         pHandle->syncBuffer.state = writeLock;
 304:Src/aspep.c   ****       }
 305:Src/aspep.c   ****       else
 306:Src/aspep.c   ****       {
 307:Src/aspep.c   ****         result = false;
 308:Src/aspep.c   ****       }
 309:Src/aspep.c   ****     }
 310:Src/aspep.c   ****     else /* Asynchronous buffer request */
 311:Src/aspep.c   ****     {
 312:Src/aspep.c   ****       if ((pHandle->asyncBufferA.state > writeLock) && (pHandle->asyncBufferB.state > writeLock))
 313:Src/aspep.c   ****       {
 314:Src/aspep.c   ****         result = false;
 315:Src/aspep.c   ****       }
 316:Src/aspep.c   ****       else
 317:Src/aspep.c   ****       {
 318:Src/aspep.c   ****         if (pHandle->asyncBufferA.state <= writeLock)
 319:Src/aspep.c   ****         {
 320:Src/aspep.c   ****           pHandle->asyncBufferA.state = writeLock;
 321:Src/aspep.c   ****           pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferA;
 322:Src/aspep.c   ****           *buffer = &pHandle->asyncBufferA.buffer[ASPEP_HEADER_SIZE];
 323:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 324:Src/aspep.c   ****           pHandle->asyncBufferA.RequestedNumber++;
 325:Src/aspep.c   **** #endif
 326:Src/aspep.c   ****         }
 327:Src/aspep.c   ****         else if (pHandle->asyncBufferB.state <= writeLock)
 328:Src/aspep.c   ****         {
 329:Src/aspep.c   ****           pHandle->asyncBufferB.state = writeLock;
 330:Src/aspep.c   ****           pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferB;
 331:Src/aspep.c   ****           *buffer = &pHandle->asyncBufferB.buffer[ASPEP_HEADER_SIZE];
 332:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 333:Src/aspep.c   ****           pHandle->asyncBufferB.RequestedNumber++;
 334:Src/aspep.c   **** #endif
 335:Src/aspep.c   ****         }
 336:Src/aspep.c   ****         else
 337:Src/aspep.c   ****         {
 338:Src/aspep.c   ****           /* Nothing to do */
 339:Src/aspep.c   ****         }
ARM GAS  /tmp/ccJS0l1g.s 			page 10


 340:Src/aspep.c   ****       }
 341:Src/aspep.c   ****     }
 342:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 343:Src/aspep.c   ****   }
 344:Src/aspep.c   **** #endif
 345:Src/aspep.c   ****   return (result);
 346:Src/aspep.c   **** }
 347:Src/aspep.c   **** 
 348:Src/aspep.c   **** /**
 349:Src/aspep.c   ****   * @brief  Checks controller's capabilities and compare them to performer's capabilities.
 350:Src/aspep.c   ****   *
 351:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 352:Src/aspep.c   ****   *
 353:Src/aspep.c   ****   * @return Returns true if controller's capabilities match performer's one. False otherwise.
 354:Src/aspep.c   ****   */
 355:Src/aspep.c   **** bool ASPEP_CheckBeacon (ASPEP_Handle_t *pHandle)
 356:Src/aspep.c   **** {
 357:Src/aspep.c   ****   bool result = true;
 358:Src/aspep.c   **** 
 359:Src/aspep.c   ****   uint32_t packetHeader = *((uint32_t *)pHandle->rxHeader); //cstat !MISRAC2012-Rule-11.3
 360:Src/aspep.c   ****   ASPEP_Capabilities_def MasterCapabilities;
 361:Src/aspep.c   ****   MasterCapabilities.version = (uint8_t)((packetHeader &0x70U)>> 4U);           /*Bits 4 to 6*/
 362:Src/aspep.c   ****   MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 363:Src/aspep.c   ****   MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 364:Src/aspep.c   ****   MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
 365:Src/aspep.c   ****   MasterCapabilities.TXA_maxSize = (uint8_t)((packetHeader&0xFE00000U) >> 21);  /*Bits 21 to 27  */
 366:Src/aspep.c   **** 
 367:Src/aspep.c   ****   pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC)
 368:Src/aspep.c   ****   pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_ma
 369:Src/aspep.c   ****   pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS
 370:Src/aspep.c   ****   pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA
 371:Src/aspep.c   **** 
 372:Src/aspep.c   ****   if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 373:Src/aspep.c   ****    /* Data packet the controller can send is bigger than performer can receive */
 374:Src/aspep.c   ****    || (MasterCapabilities.RX_maxSize > pHandle->Capabilities.RX_maxSize)
 375:Src/aspep.c   ****    /* Sync packet size alignement is required in order for the controller to be able to store it, a
 376:Src/aspep.c   ****     * response bigger than performer capability */
 377:Src/aspep.c   ****    || (pHandle->Capabilities.TXS_maxSize != MasterCapabilities.TXS_maxSize )
 378:Src/aspep.c   ****    /* Async packet the performer can send is bigger than the controller can receive (but controller
 379:Src/aspep.c   ****     * packet than performer can transmit) */
 380:Src/aspep.c   ****    || (pHandle->Capabilities.TXA_maxSize != MasterCapabilities.TXA_maxSize )
 381:Src/aspep.c   ****    /* For the time being, controller version has to match performer version */
 382:Src/aspep.c   ****    || (MasterCapabilities.version != pHandle->Capabilities.version) )
 383:Src/aspep.c   ****   {
 384:Src/aspep.c   ****     result = false;
 385:Src/aspep.c   ****   }
 386:Src/aspep.c   ****   else
 387:Src/aspep.c   ****   {
 388:Src/aspep.c   ****     /* Nothing to do */
 389:Src/aspep.c   ****   }
 390:Src/aspep.c   **** 
 391:Src/aspep.c   ****   return (result);
 392:Src/aspep.c   **** }
 393:Src/aspep.c   **** 
 394:Src/aspep.c   **** /**
 395:Src/aspep.c   ****   * @brief  Checks if any error has occurred and calls the ASPEP_TXframeProcess function.
 396:Src/aspep.c   ****   *
ARM GAS  /tmp/ccJS0l1g.s 			page 11


 397:Src/aspep.c   ****   * @param  *pSupHandle Handler of the current instance of the MCTL component
 398:Src/aspep.c   ****   * @param  *txBuffer can be 8, 16 or 32 bits, but must be 32 bits aligned
 399:Src/aspep.c   ****   * @param  txDataLength Size of useful data in byte
 400:Src/aspep.c   ****   * @param  syncAsync nature of the communication : synchronous or asynchronous
 401:Src/aspep.c   ****   *
 402:Src/aspep.c   ****   * @return Returns an ASPEP response defined in aspep.h
 403:Src/aspep.c   ****   */
 404:Src/aspep.c   **** uint8_t ASPEP_sendPacket(MCTL_Handle_t *pSupHandle, void *txBuffer, uint16_t txDataLength, uint8_t 
 405:Src/aspep.c   **** {
 406:Src/aspep.c   ****   uint8_t result = ASPEP_OK;
 407:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 408:Src/aspep.c   ****   if ((MC_NULL == pSupHandle) || (MC_NULL == txBuffer))
 409:Src/aspep.c   ****   {
 410:Src/aspep.c   ****     result = ASPEP_BUFFER_ERROR;
 411:Src/aspep.c   ****   }
 412:Src/aspep.c   ****   else
 413:Src/aspep.c   ****   {
 414:Src/aspep.c   **** #endif
 415:Src/aspep.c   ****     uint32_t *header;
 416:Src/aspep.c   ****     uint32_t tmpHeader;
 417:Src/aspep.c   ****     uint16_t txDataLengthTemp;
 418:Src/aspep.c   ****     uint8_t *packet;
 419:Src/aspep.c   **** 
 420:Src/aspep.c   ****     txDataLengthTemp = txDataLength;
 421:Src/aspep.c   ****     ASPEP_Handle_t *pHandle = (ASPEP_Handle_t *)pSupHandle; //cstat !MISRAC2012-Rule-11.3
 422:Src/aspep.c   **** 
 423:Src/aspep.c   ****     if (ASPEP_CONNECTED == pHandle-> ASPEP_State)
 424:Src/aspep.c   ****     {
 425:Src/aspep.c   ****       /*We must add packet header on  */
 426:Src/aspep.c   ****       /* | [0101|0011] | Length 13b | Reserved |CRCH 4b| */
 427:Src/aspep.c   ****       packet = (uint8_t *)txBuffer; //cstat !MISRAC2012-Rule-11.5
 428:Src/aspep.c   ****       header = (uint32_t *)txBuffer; //cstat !MISRAC2012-Rule-11.5
 429:Src/aspep.c   ****       header--; /* Header ues 4*8 bits on top of txBuffer*/
 430:Src/aspep.c   ****       tmpHeader = ((uint32_t)((uint32_t)txDataLengthTemp << (uint32_t)4) | (uint32_t)syncAsync);
 431:Src/aspep.c   ****       *header = tmpHeader;
 432:Src/aspep.c   ****       if (1U == pHandle->Capabilities.DATA_CRC)
 433:Src/aspep.c   ****       {
 434:Src/aspep.c   ****         /* TODO : Compute real CRC*/
 435:Src/aspep.c   ****         packet[txDataLengthTemp] = (uint8_t)0xCA; /* Dummy CRC */
 436:Src/aspep.c   ****         packet[txDataLengthTemp + 1U] = (uint8_t)0xFE; /* Dummy CRC */
 437:Src/aspep.c   ****         txDataLengthTemp += (uint16_t)ASPEP_DATACRC_SIZE;
 438:Src/aspep.c   ****       }
 439:Src/aspep.c   ****       if (MCTL_SYNC == syncAsync)
 440:Src/aspep.c   ****       {
 441:Src/aspep.c   ****         if (pSupHandle->MCP_PacketAvailable)
 442:Src/aspep.c   ****         {
 443:Src/aspep.c   ****           pSupHandle->MCP_PacketAvailable = false; /* CMD from controller is processed*/
 444:Src/aspep.c   ****         }
 445:Src/aspep.c   ****         else
 446:Src/aspep.c   ****         {
 447:Src/aspep.c   ****           result = MCTL_SYNC_NOT_EXPECTED;
 448:Src/aspep.c   ****         }
 449:Src/aspep.c   ****       }
 450:Src/aspep.c   ****       if (ASPEP_OK == result) /* Send packet only if no error detected so far*/
 451:Src/aspep.c   ****       {
 452:Src/aspep.c   ****         result = ASPEP_TXframeProcess(pHandle, syncAsync, header, txDataLengthTemp + (uint16_t)ASPE
 453:Src/aspep.c   ****       }
ARM GAS  /tmp/ccJS0l1g.s 			page 12


 454:Src/aspep.c   ****     }
 455:Src/aspep.c   ****     else
 456:Src/aspep.c   ****     {
 457:Src/aspep.c   ****       result = ASPEP_NOT_CONNECTED;
 458:Src/aspep.c   ****     }
 459:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 460:Src/aspep.c   ****   }
 461:Src/aspep.c   **** #endif
 462:Src/aspep.c   ****   return (result);
 463:Src/aspep.c   **** }
 464:Src/aspep.c   **** 
 465:Src/aspep.c   **** /**
 466:Src/aspep.c   ****   * @brief  Checks if HW resource is busy before sending packet. Otherwise saves packet for next op
 467:Src/aspep.c   ****   *
 468:Src/aspep.c   ****   * This function contains a critical section.
 469:Src/aspep.c   ****   * It can be accessed concurently under High frequency task (by MCPA_datalog)
 470:Src/aspep.c   ****   * and under Medium frequency task (MC_Scheduler -> ASPEP_RxFrameProcess ).
 471:Src/aspep.c   ****   *
 472:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 473:Src/aspep.c   ****   * @param  dataType Nature of the communication : synchronous, asynchronous or a CTL packet
 474:Src/aspep.c   ****   * @param  *txBuffer CRC Header to be computed in sent packet
 475:Src/aspep.c   ****   * @param  bufferLength Size of the packet to be sent : Header + Data
 476:Src/aspep.c   ****   *
 477:Src/aspep.c   ****   * @return Returns an ASPEP response defined in aspep.h
 478:Src/aspep.c   ****   */
 479:Src/aspep.c   **** uint8_t ASPEP_TXframeProcess(ASPEP_Handle_t *pHandle, uint8_t dataType, void *txBuffer, uint16_t bu
 160              		.loc 1 479 9 view .LVU37
 161              	.LBB59:
 480:Src/aspep.c   **** {
 481:Src/aspep.c   ****   uint8_t result = ASPEP_OK;
 162              		.loc 1 481 3 view .LVU38
 482:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 483:Src/aspep.c   ****   if (MC_NULL == txBuffer)
 484:Src/aspep.c   ****   {
 485:Src/aspep.c   ****     result = ASPEP_BUFFER_ERROR;
 486:Src/aspep.c   ****   }
 487:Src/aspep.c   ****   else
 488:Src/aspep.c   ****   {
 489:Src/aspep.c   **** #endif
 490:Src/aspep.c   ****     /* Insert CRC header in the packet to send */
 491:Src/aspep.c   ****     ASPEP_ComputeHeaderCRC((uint32_t *)txBuffer); //cstat !MISRAC2012-Rule-11.5
 163              		.loc 1 491 5 view .LVU39
 164              	.LBB51:
 165              	.LBI46:
 118:Src/aspep.c   **** {
 166              		.loc 1 118 13 view .LVU40
 167              	.LBB49:
 120:Src/aspep.c   ****   uint32_t header = *headerPtr;
 168              		.loc 1 120 3 view .LVU41
 121:Src/aspep.c   **** 
 169              		.loc 1 121 3 view .LVU42
 124:Src/aspep.c   **** 
 170              		.loc 1 124 3 view .LVU43
 126:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 171              		.loc 1 126 3 view .LVU44
 127:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 172              		.loc 1 127 3 view .LVU45
ARM GAS  /tmp/ccJS0l1g.s 			page 13


 128:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 173              		.loc 1 128 3 view .LVU46
 128:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 174              		.loc 1 128 26 is_stmt 0 view .LVU47
 175 0038 615C     		ldrb	r1, [r4, r1]	@ zero_extendqisi2
 176              	.LVL8:
 128:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 177              		.loc 1 128 26 view .LVU48
 178 003a 81EA1241 		eor	r1, r1, r2, lsr #16
 179 003e C9B2     		uxtb	r1, r1
 180              	.LVL9:
 129:Src/aspep.c   **** #else /* CRC4_PER_NIBBLE */
 181              		.loc 1 129 3 is_stmt 1 view .LVU49
 129:Src/aspep.c   **** #else /* CRC4_PER_NIBBLE */
 182              		.loc 1 129 26 is_stmt 0 view .LVU50
 183 0040 615C     		ldrb	r1, [r4, r1]	@ zero_extendqisi2
 184              	.LVL10:
 129:Src/aspep.c   **** #else /* CRC4_PER_NIBBLE */
 185              		.loc 1 129 26 view .LVU51
 186 0042 81EA1262 		eor	r2, r1, r2, lsr #24
 187              	.LVL11:
 140:Src/aspep.c   **** 
 188              		.loc 1 140 3 is_stmt 1 view .LVU52
 140:Src/aspep.c   **** 
 189              		.loc 1 140 17 is_stmt 0 view .LVU53
 190 0046 AA5C     		ldrb	r2, [r5, r2]	@ zero_extendqisi2
 191              	.LVL12:
 140:Src/aspep.c   **** 
 192              		.loc 1 140 14 view .LVU54
 193 0048 43EA0273 		orr	r3, r3, r2, lsl #28
 194              	.LVL13:
 140:Src/aspep.c   **** 
 195              		.loc 1 140 14 view .LVU55
 196 004c 43F00503 		orr	r3, r3, #5
 197 0050 0362     		str	r3, [r0, #32]
 198              	.LVL14:
 140:Src/aspep.c   **** 
 199              		.loc 1 140 14 view .LVU56
 200              	.LBE49:
 201              	.LBE51:
 492:Src/aspep.c   ****     __disable_irq(); /*TODO: Disable High frequency task is enough */
 202              		.loc 1 492 5 is_stmt 1 view .LVU57
 203              	.LBB52:
 204              	.LBI52:
 205              		.file 2 "Drivers/CMSIS/Include/cmsis_gcc.h"
   1:Drivers/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.2.0
   5:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @date     08. May 2019
   6:Drivers/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/cmsis_gcc.h **** /*
   8:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2019 Arm Limited. All rights reserved.
   9:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  10:Drivers/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  12:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
ARM GAS  /tmp/ccJS0l1g.s 			page 14


  13:Drivers/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:Drivers/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  16:Drivers/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  18:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:Drivers/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:Drivers/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:Drivers/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:Drivers/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  24:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  25:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  28:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  34:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __has_builtin
  36:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  38:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  39:Drivers/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  41:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  43:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  44:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                               inline
  45:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  46:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  49:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif                                           
  52:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  55:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  56:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  58:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  59:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  61:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  62:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  64:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  67:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
ARM GAS  /tmp/ccJS0l1g.s 			page 15


  70:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:Drivers/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  78:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  86:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  94:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 102:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 110:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 113:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __RESTRICT
 114:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 116:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __COMPILER_BARRIER
 117:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __COMPILER_BARRIER()                   __ASM volatile("":::"memory")
 118:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 119:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 120:Drivers/CMSIS/Include/cmsis_gcc.h **** /* #########################  Startup and Lowlevel Init  ######################## */
 121:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 122:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __PROGRAM_START
 123:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 124:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 125:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Initializes data and bss sections
 126:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details This default implementations initialized all data and additional bss
ARM GAS  /tmp/ccJS0l1g.s 			page 16


 127:Drivers/CMSIS/Include/cmsis_gcc.h ****            sections relying on .copy.table and .zero.table specified properly
 128:Drivers/CMSIS/Include/cmsis_gcc.h ****            in the used linker script.
 129:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 130:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 131:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE __NO_RETURN void __cmsis_start(void)
 132:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 133:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern void _start(void) __NO_RETURN;
 134:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 135:Drivers/CMSIS/Include/cmsis_gcc.h ****   typedef struct {
 136:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t const* src;
 137:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t* dest;
 138:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t  wlen;
 139:Drivers/CMSIS/Include/cmsis_gcc.h ****   } __copy_table_t;
 140:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 141:Drivers/CMSIS/Include/cmsis_gcc.h ****   typedef struct {
 142:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t* dest;
 143:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t  wlen;
 144:Drivers/CMSIS/Include/cmsis_gcc.h ****   } __zero_table_t;
 145:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 146:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __copy_table_t __copy_table_start__;
 147:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __copy_table_t __copy_table_end__;
 148:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __zero_table_t __zero_table_start__;
 149:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __zero_table_t __zero_table_end__;
 150:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 151:Drivers/CMSIS/Include/cmsis_gcc.h ****   for (__copy_table_t const* pTable = &__copy_table_start__; pTable < &__copy_table_end__; ++pTable
 152:Drivers/CMSIS/Include/cmsis_gcc.h ****     for(uint32_t i=0u; i<pTable->wlen; ++i) {
 153:Drivers/CMSIS/Include/cmsis_gcc.h ****       pTable->dest[i] = pTable->src[i];
 154:Drivers/CMSIS/Include/cmsis_gcc.h ****     }
 155:Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 156:Drivers/CMSIS/Include/cmsis_gcc.h ****  
 157:Drivers/CMSIS/Include/cmsis_gcc.h ****   for (__zero_table_t const* pTable = &__zero_table_start__; pTable < &__zero_table_end__; ++pTable
 158:Drivers/CMSIS/Include/cmsis_gcc.h ****     for(uint32_t i=0u; i<pTable->wlen; ++i) {
 159:Drivers/CMSIS/Include/cmsis_gcc.h ****       pTable->dest[i] = 0u;
 160:Drivers/CMSIS/Include/cmsis_gcc.h ****     }
 161:Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 162:Drivers/CMSIS/Include/cmsis_gcc.h ****  
 163:Drivers/CMSIS/Include/cmsis_gcc.h ****   _start();
 164:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 165:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 166:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __PROGRAM_START           __cmsis_start
 167:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 168:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 169:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __INITIAL_SP
 170:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __INITIAL_SP              __StackTop
 171:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 172:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 173:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __STACK_LIMIT
 174:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __STACK_LIMIT             __StackLimit
 175:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 176:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 177:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __VECTOR_TABLE
 178:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __VECTOR_TABLE            __Vectors
 179:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 180:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 181:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __VECTOR_TABLE_ATTRIBUTE
 182:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __VECTOR_TABLE_ATTRIBUTE  __attribute((used, section(".vectors")))
 183:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
ARM GAS  /tmp/ccJS0l1g.s 			page 17


 184:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 185:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 186:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 187:Drivers/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 188:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 189:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 190:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 191:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 192:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 193:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 194:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 195:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 196:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 197:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 198:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 199:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 200:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 201:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 202:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 203:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 204:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 205:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 206:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 207:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 206              		.loc 2 207 27 view .LVU58
 207              	.LBB53:
 208:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 209:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 208              		.loc 2 209 3 view .LVU59
 209              		.syntax unified
 210              	@ 209 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 211 0052 72B6     		cpsid i
 212              	@ 0 "" 2
 213              		.thumb
 214              		.syntax unified
 215              	.LBE53:
 216              	.LBE52:
 493:Src/aspep.c   ****     if (NULL == pHandle->lockBuffer) /* Communication Ip free to send data*/
 217              		.loc 1 493 5 view .LVU60
 218              		.loc 1 493 8 is_stmt 0 view .LVU61
 219 0054 836C     		ldr	r3, [r0, #72]
 220 0056 43B1     		cbz	r3, .L8
 494:Src/aspep.c   ****     {
 495:Src/aspep.c   ****       if (MCTL_ASYNC == dataType)
 496:Src/aspep.c   ****       {
 497:Src/aspep.c   ****         /* In ASYNC, two flipflop buffers are used, the txBuffer points always to lastRequestedAsyn
 498:Src/aspep.c   ****         pHandle->lastRequestedAsyncBuff->state = readLock;
 499:Src/aspep.c   ****         pHandle->lockBuffer = (void *)pHandle->lastRequestedAsyncBuff;
 500:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 501:Src/aspep.c   ****         pHandle->lastRequestedAsyncBuff->SentNumber++;
 502:Src/aspep.c   **** #endif
 503:Src/aspep.c   ****       }
 504:Src/aspep.c   ****       else if (MCTL_SYNC == dataType)
 505:Src/aspep.c   ****       {
 506:Src/aspep.c   ****         pHandle->syncBuffer.state = readLock;
 507:Src/aspep.c   ****         pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
 508:Src/aspep.c   ****       }
ARM GAS  /tmp/ccJS0l1g.s 			page 18


 509:Src/aspep.c   ****       else
 510:Src/aspep.c   ****       {
 511:Src/aspep.c   ****         pHandle->ctrlBuffer.state = readLock;
 512:Src/aspep.c   ****         pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 513:Src/aspep.c   ****       }
 514:Src/aspep.c   ****       /* Enable HF task It */
 515:Src/aspep.c   ****       __enable_irq(); /*TODO: Enable High frequency task is enough */
 516:Src/aspep.c   ****       pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, txBuffer, bufferLength);
 517:Src/aspep.c   ****     }
 518:Src/aspep.c   ****     else /* HW resource busy, saving packet to sent it once resource will be freed*/
 519:Src/aspep.c   ****     {
 520:Src/aspep.c   ****       __enable_irq(); /*TODO: Enable High frequency task is enough */
 221              		.loc 1 520 7 is_stmt 1 view .LVU62
 222              	.LBB54:
 223              	.LBI54:
 196:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 224              		.loc 2 196 27 view .LVU63
 225              	.LBB55:
 198:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 226              		.loc 2 198 3 view .LVU64
 227              		.syntax unified
 228              	@ 198 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 229 0058 62B6     		cpsie i
 230              	@ 0 "" 2
 231              		.thumb
 232              		.syntax unified
 233              	.LBE55:
 234              	.LBE54:
 521:Src/aspep.c   ****       /* Lock buffer can be freed here */
 522:Src/aspep.c   ****       if (MCTL_ASYNC == dataType)
 235              		.loc 1 522 7 view .LVU65
 523:Src/aspep.c   ****       {
 524:Src/aspep.c   ****         /* Check that the buffer received is the one expected - probably useless */
 525:Src/aspep.c   ****         if (txBuffer != (uint8_t *)pHandle->lastRequestedAsyncBuff->buffer)
 526:Src/aspep.c   ****         {
 527:Src/aspep.c   ****           result = ASPEP_BUFFER_ERROR;
 528:Src/aspep.c   ****         }
 529:Src/aspep.c   ****         else
 530:Src/aspep.c   ****         {
 531:Src/aspep.c   ****           /* Nothing to do */
 532:Src/aspep.c   ****         }
 533:Src/aspep.c   ****         if (NULL == pHandle->asyncNextBuffer)
 534:Src/aspep.c   ****         {
 535:Src/aspep.c   ****           /* Required to keep the right sending order */
 536:Src/aspep.c   ****           pHandle->asyncNextBuffer = pHandle->lastRequestedAsyncBuff;
 537:Src/aspep.c   ****         }
 538:Src/aspep.c   ****         else
 539:Src/aspep.c   ****         {
 540:Src/aspep.c   ****           /* Nothing to do */
 541:Src/aspep.c   ****         }
 542:Src/aspep.c   ****         pHandle->lastRequestedAsyncBuff->state = pending;
 543:Src/aspep.c   ****         pHandle->lastRequestedAsyncBuff->length = bufferLength;
 544:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 545:Src/aspep.c   ****         pHandle->lastRequestedAsyncBuff->PendingNumber++;
 546:Src/aspep.c   **** #endif
 547:Src/aspep.c   ****       }
 548:Src/aspep.c   ****       else if (MCTL_SYNC == dataType)
ARM GAS  /tmp/ccJS0l1g.s 			page 19


 236              		.loc 1 548 12 view .LVU66
 549:Src/aspep.c   ****       {
 550:Src/aspep.c   ****         if (pHandle -> syncBuffer.state != writeLock)
 551:Src/aspep.c   ****         {
 552:Src/aspep.c   ****           result = ASPEP_BUFFER_ERROR;
 553:Src/aspep.c   ****         }
 554:Src/aspep.c   ****         else
 555:Src/aspep.c   ****         {
 556:Src/aspep.c   ****           pHandle->syncBuffer.state = pending;
 557:Src/aspep.c   ****           pHandle->syncBuffer.length = bufferLength;
 558:Src/aspep.c   ****         }
 559:Src/aspep.c   ****       }
 560:Src/aspep.c   ****       else if(ASPEP_CTRL == dataType)
 237              		.loc 1 560 12 view .LVU67
 561:Src/aspep.c   ****       {
 562:Src/aspep.c   ****         if (pHandle->ctrlBuffer.state != available)
 238              		.loc 1 562 9 view .LVU68
 239              		.loc 1 562 12 is_stmt 0 view .LVU69
 240 005a 90F82430 		ldrb	r3, [r0, #36]	@ zero_extendqisi2
 241 005e 13B9     		cbnz	r3, .L4
 563:Src/aspep.c   ****         {
 564:Src/aspep.c   ****           result = ASPEP_BUFFER_ERROR;
 565:Src/aspep.c   ****         }
 566:Src/aspep.c   ****         else
 567:Src/aspep.c   ****         {
 568:Src/aspep.c   ****           pHandle->ctrlBuffer.state = pending;
 242              		.loc 1 568 11 is_stmt 1 view .LVU70
 243              		.loc 1 568 37 is_stmt 0 view .LVU71
 244 0060 0223     		movs	r3, #2
 245 0062 80F82430 		strb	r3, [r0, #36]
 246              	.LVL15:
 569:Src/aspep.c   ****         }
 570:Src/aspep.c   ****       }
 571:Src/aspep.c   ****       else
 572:Src/aspep.c   ****       {
 573:Src/aspep.c   ****         /* Nothing to do */
 574:Src/aspep.c   ****       }
 247              		.loc 1 574 7 is_stmt 1 view .LVU72
 575:Src/aspep.c   ****     }
 576:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 577:Src/aspep.c   ****   }
 578:Src/aspep.c   **** #endif
 579:Src/aspep.c   ****   return (result);
 248              		.loc 1 579 3 view .LVU73
 249              	.L4:
 250              		.loc 1 579 3 is_stmt 0 view .LVU74
 251              	.LBE59:
 252              	.LBE63:
 229:Src/aspep.c   **** 
 253              		.loc 1 229 1 view .LVU75
 254 0066 30BC     		pop	{r4, r5}
 255              	.LCFI3:
 256              		.cfi_remember_state
 257              		.cfi_restore 5
 258              		.cfi_restore 4
 259              		.cfi_def_cfa_offset 0
 260 0068 7047     		bx	lr
ARM GAS  /tmp/ccJS0l1g.s 			page 20


 261              	.LVL16:
 262              	.L8:
 263              	.LCFI4:
 264              		.cfi_restore_state
 225:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 265              		.loc 1 225 53 view .LVU76
 266 006a 00F12001 		add	r1, r0, #32
 267              	.LBB64:
 268              	.LBB60:
 495:Src/aspep.c   ****       {
 269              		.loc 1 495 7 is_stmt 1 view .LVU77
 504:Src/aspep.c   ****       {
 270              		.loc 1 504 12 view .LVU78
 511:Src/aspep.c   ****         pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 271              		.loc 1 511 9 view .LVU79
 511:Src/aspep.c   ****         pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 272              		.loc 1 511 35 is_stmt 0 view .LVU80
 273 006e 0323     		movs	r3, #3
 512:Src/aspep.c   ****       }
 274              		.loc 1 512 29 view .LVU81
 275 0070 8164     		str	r1, [r0, #72]
 511:Src/aspep.c   ****         pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 276              		.loc 1 511 35 view .LVU82
 277 0072 80F82430 		strb	r3, [r0, #36]
 512:Src/aspep.c   ****       }
 278              		.loc 1 512 9 is_stmt 1 view .LVU83
 515:Src/aspep.c   ****       pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, txBuffer, bufferLength);
 279              		.loc 1 515 7 view .LVU84
 280              	.LBB56:
 281              	.LBI56:
 196:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 282              		.loc 2 196 27 view .LVU85
 283              	.LBB57:
 198:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 284              		.loc 2 198 3 view .LVU86
 285              		.syntax unified
 286              	@ 198 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 287 0076 62B6     		cpsie i
 288              	@ 0 "" 2
 289              		.thumb
 290              		.syntax unified
 291              	.LBE57:
 292              	.LBE56:
 516:Src/aspep.c   ****     }
 293              		.loc 1 516 7 view .LVU87
 294 0078 0422     		movs	r2, #4
 295 007a 836D     		ldr	r3, [r0, #88]
 296 007c 4069     		ldr	r0, [r0, #20]
 297              	.LVL17:
 516:Src/aspep.c   ****     }
 298              		.loc 1 516 7 is_stmt 0 view .LVU88
 299              	.LBE60:
 300              	.LBE64:
 229:Src/aspep.c   **** 
 301              		.loc 1 229 1 view .LVU89
 302 007e 30BC     		pop	{r4, r5}
 303              	.LCFI5:
ARM GAS  /tmp/ccJS0l1g.s 			page 21


 304              		.cfi_restore 5
 305              		.cfi_restore 4
 306              		.cfi_def_cfa_offset 0
 307              	.LBB65:
 308              	.LBB61:
 516:Src/aspep.c   ****     }
 309              		.loc 1 516 7 view .LVU90
 310 0080 1847     		bx	r3	@ indirect register sibling call
 311              	.LVL18:
 312              	.L10:
 516:Src/aspep.c   ****     }
 313              		.loc 1 516 7 view .LVU91
 314 0082 00BF     		.align	2
 315              	.L9:
 316 0084 00000000 		.word	.LANCHOR0
 317 0088 00000000 		.word	.LANCHOR1
 318              	.LBE61:
 319              	.LBE65:
 320              		.cfi_endproc
 321              	.LFE1440:
 323              		.section	.text.ASPEP_sendPing,"ax",%progbits
 324              		.align	1
 325              		.p2align 2,,3
 326              		.global	ASPEP_sendPing
 327              		.syntax unified
 328              		.thumb
 329              		.thumb_func
 330              		.fpu fpv4-sp-d16
 332              	ASPEP_sendPing:
 333              	.LVL19:
 334              	.LFB1442:
 252:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 335              		.loc 1 252 1 is_stmt 1 view -0
 336              		.cfi_startproc
 337              		@ args = 0, pretend = 0, frame = 0
 338              		@ frame_needed = 0, uses_anonymous_args = 0
 339              		@ link register save eliminated.
 261:Src/aspep.c   ****     uint8_t Nbit = pHandle->syncPacketCount & 0x1U; /* Keep only LSB */
 340              		.loc 1 261 5 view .LVU93
 262:Src/aspep.c   ****     uint8_t ipID = pHandle->liid & 0xFU;
 341              		.loc 1 262 5 view .LVU94
 263:Src/aspep.c   ****     *packet = PING | (uint32_t)((uint32_t)cBit << 4U)
 342              		.loc 1 263 5 view .LVU95
 264:Src/aspep.c   ****                    | (uint32_t)((uint32_t)cBit << 5U)
 343              		.loc 1 264 5 view .LVU96
 252:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 344              		.loc 1 252 1 is_stmt 0 view .LVU97
 345 0000 30B4     		push	{r4, r5}
 346              	.LCFI6:
 347              		.cfi_def_cfa_offset 8
 348              		.cfi_offset 4, -8
 349              		.cfi_offset 5, -4
 265:Src/aspep.c   ****                    | (uint32_t)((uint32_t)Nbit << 6U)
 350              		.loc 1 265 22 view .LVU98
 351 0002 4C01     		lsls	r4, r1, #5
 262:Src/aspep.c   ****     uint8_t ipID = pHandle->liid & 0xFU;
 352              		.loc 1 262 13 view .LVU99
ARM GAS  /tmp/ccJS0l1g.s 			page 22


 353 0004 90F86030 		ldrb	r3, [r0, #96]	@ zero_extendqisi2
 263:Src/aspep.c   ****     *packet = PING | (uint32_t)((uint32_t)cBit << 4U)
 354              		.loc 1 263 13 view .LVU100
 355 0008 90F86350 		ldrb	r5, [r0, #99]	@ zero_extendqisi2
 269:Src/aspep.c   ****     (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 356              		.loc 1 269 20 view .LVU101
 357 000c 44EA0111 		orr	r1, r4, r1, lsl #4
 358              	.LVL20:
 269:Src/aspep.c   ****     (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 359              		.loc 1 269 20 view .LVU102
 360 0010 41EA0231 		orr	r1, r1, r2, lsl #12
 266:Src/aspep.c   ****                    | (uint32_t)((uint32_t)Nbit << 7U)
 361              		.loc 1 266 33 view .LVU103
 362 0014 03F00104 		and	r4, r3, #1
 269:Src/aspep.c   ****     (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 363              		.loc 1 269 20 view .LVU104
 364 0018 41EA8413 		orr	r3, r1, r4, lsl #6
 365 001c 43EAC413 		orr	r3, r3, r4, lsl #7
 268:Src/aspep.c   ****                    | (uint32_t)(((uint32_t) packetNumber) << 12U);
 366              		.loc 1 268 33 view .LVU105
 367 0020 05F00F05 		and	r5, r5, #15
 269:Src/aspep.c   ****     (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 368              		.loc 1 269 20 view .LVU106
 369 0024 43EA0523 		orr	r3, r3, r5, lsl #8
 370              	.LBB76:
 371              	.LBB77:
 372              	.LBB78:
 373              	.LBB79:
 126:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 374              		.loc 1 126 26 view .LVU107
 375 0028 DAB2     		uxtb	r2, r3
 376              	.LVL21:
 126:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 377              		.loc 1 126 7 view .LVU108
 378 002a 1649     		ldr	r1, .L16
 129:Src/aspep.c   **** #else /* CRC4_PER_NIBBLE */
 379              		.loc 1 129 7 view .LVU109
 380 002c 164C     		ldr	r4, .L16+4
 126:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 381              		.loc 1 126 26 view .LVU110
 382 002e 42F00602 		orr	r2, r2, #6
 383              	.LBE79:
 384              	.LBE78:
 385              	.LBE77:
 386              	.LBE76:
 269:Src/aspep.c   ****     (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 387              		.loc 1 269 20 view .LVU111
 388 0032 43F00603 		orr	r3, r3, #6
 389              	.LBB94:
 390              	.LBB90:
 391              	.LBB82:
 392              	.LBB80:
 127:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 393              		.loc 1 127 26 view .LVU112
 394 0036 8A5C     		ldrb	r2, [r1, r2]	@ zero_extendqisi2
 395              	.LBE80:
 396              	.LBE82:
ARM GAS  /tmp/ccJS0l1g.s 			page 23


 397              	.LBE90:
 398              	.LBE94:
 270:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 399              		.loc 1 270 5 is_stmt 1 view .LVU113
 400              	.LVL22:
 401              	.LBB95:
 402              	.LBI76:
 479:Src/aspep.c   **** {
 403              		.loc 1 479 9 view .LVU114
 404              	.LBB91:
 481:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 405              		.loc 1 481 3 view .LVU115
 491:Src/aspep.c   ****     __disable_irq(); /*TODO: Disable High frequency task is enough */
 406              		.loc 1 491 5 view .LVU116
 407              	.LBB83:
 408              	.LBI78:
 118:Src/aspep.c   **** {
 409              		.loc 1 118 13 view .LVU117
 410              	.LBB81:
 120:Src/aspep.c   ****   uint32_t header = *headerPtr;
 411              		.loc 1 120 3 view .LVU118
 121:Src/aspep.c   **** 
 412              		.loc 1 121 3 view .LVU119
 124:Src/aspep.c   **** 
 413              		.loc 1 124 3 view .LVU120
 126:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 414              		.loc 1 126 3 view .LVU121
 127:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 415              		.loc 1 127 3 view .LVU122
 127:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 416              		.loc 1 127 26 is_stmt 0 view .LVU123
 417 0038 82EA1322 		eor	r2, r2, r3, lsr #8
 418 003c D2B2     		uxtb	r2, r2
 419              	.LVL23:
 128:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 420              		.loc 1 128 3 is_stmt 1 view .LVU124
 128:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 421              		.loc 1 128 26 is_stmt 0 view .LVU125
 422 003e 8A5C     		ldrb	r2, [r1, r2]	@ zero_extendqisi2
 423              	.LVL24:
 128:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 424              		.loc 1 128 26 view .LVU126
 425 0040 82EA1342 		eor	r2, r2, r3, lsr #16
 426 0044 D2B2     		uxtb	r2, r2
 427              	.LVL25:
 129:Src/aspep.c   **** #else /* CRC4_PER_NIBBLE */
 428              		.loc 1 129 3 is_stmt 1 view .LVU127
 129:Src/aspep.c   **** #else /* CRC4_PER_NIBBLE */
 429              		.loc 1 129 26 is_stmt 0 view .LVU128
 430 0046 8A5C     		ldrb	r2, [r1, r2]	@ zero_extendqisi2
 431              	.LVL26:
 129:Src/aspep.c   **** #else /* CRC4_PER_NIBBLE */
 432              		.loc 1 129 26 view .LVU129
 433 0048 82EA1362 		eor	r2, r2, r3, lsr #24
 434              	.LVL27:
 140:Src/aspep.c   **** 
 435              		.loc 1 140 3 is_stmt 1 view .LVU130
ARM GAS  /tmp/ccJS0l1g.s 			page 24


 140:Src/aspep.c   **** 
 436              		.loc 1 140 17 is_stmt 0 view .LVU131
 437 004c A25C     		ldrb	r2, [r4, r2]	@ zero_extendqisi2
 438              	.LVL28:
 140:Src/aspep.c   **** 
 439              		.loc 1 140 14 view .LVU132
 440 004e 43EA0273 		orr	r3, r3, r2, lsl #28
 441              	.LVL29:
 140:Src/aspep.c   **** 
 442              		.loc 1 140 14 view .LVU133
 443 0052 0362     		str	r3, [r0, #32]
 444              	.LVL30:
 140:Src/aspep.c   **** 
 445              		.loc 1 140 14 view .LVU134
 446              	.LBE81:
 447              	.LBE83:
 492:Src/aspep.c   ****     if (NULL == pHandle->lockBuffer) /* Communication Ip free to send data*/
 448              		.loc 1 492 5 is_stmt 1 view .LVU135
 449              	.LBB84:
 450              	.LBI84:
 207:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 451              		.loc 2 207 27 view .LVU136
 452              	.LBB85:
 453              		.loc 2 209 3 view .LVU137
 454              		.syntax unified
 455              	@ 209 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 456 0054 72B6     		cpsid i
 457              	@ 0 "" 2
 458              		.thumb
 459              		.syntax unified
 460              	.LBE85:
 461              	.LBE84:
 493:Src/aspep.c   ****     {
 462              		.loc 1 493 5 view .LVU138
 493:Src/aspep.c   ****     {
 463              		.loc 1 493 8 is_stmt 0 view .LVU139
 464 0056 836C     		ldr	r3, [r0, #72]
 465 0058 43B1     		cbz	r3, .L15
 520:Src/aspep.c   ****       /* Lock buffer can be freed here */
 466              		.loc 1 520 7 is_stmt 1 view .LVU140
 467              	.LBB86:
 468              	.LBI86:
 196:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 469              		.loc 2 196 27 view .LVU141
 470              	.LBB87:
 198:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 471              		.loc 2 198 3 view .LVU142
 472              		.syntax unified
 473              	@ 198 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 474 005a 62B6     		cpsie i
 475              	@ 0 "" 2
 476              		.thumb
 477              		.syntax unified
 478              	.LBE87:
 479              	.LBE86:
 522:Src/aspep.c   ****       {
 480              		.loc 1 522 7 view .LVU143
ARM GAS  /tmp/ccJS0l1g.s 			page 25


 548:Src/aspep.c   ****       {
 481              		.loc 1 548 12 view .LVU144
 560:Src/aspep.c   ****       {
 482              		.loc 1 560 12 view .LVU145
 562:Src/aspep.c   ****         {
 483              		.loc 1 562 9 view .LVU146
 562:Src/aspep.c   ****         {
 484              		.loc 1 562 12 is_stmt 0 view .LVU147
 485 005c 90F82430 		ldrb	r3, [r0, #36]	@ zero_extendqisi2
 486 0060 13B9     		cbnz	r3, .L11
 568:Src/aspep.c   ****         }
 487              		.loc 1 568 11 is_stmt 1 view .LVU148
 568:Src/aspep.c   ****         }
 488              		.loc 1 568 37 is_stmt 0 view .LVU149
 489 0062 0223     		movs	r3, #2
 490 0064 80F82430 		strb	r3, [r0, #36]
 491              	.LVL31:
 574:Src/aspep.c   ****     }
 492              		.loc 1 574 7 is_stmt 1 view .LVU150
 493              		.loc 1 579 3 view .LVU151
 494              	.L11:
 495              		.loc 1 579 3 is_stmt 0 view .LVU152
 496              	.LBE91:
 497              	.LBE95:
 274:Src/aspep.c   **** 
 498              		.loc 1 274 1 view .LVU153
 499 0068 30BC     		pop	{r4, r5}
 500              	.LCFI7:
 501              		.cfi_remember_state
 502              		.cfi_restore 5
 503              		.cfi_restore 4
 504              		.cfi_def_cfa_offset 0
 505 006a 7047     		bx	lr
 506              	.LVL32:
 507              	.L15:
 508              	.LCFI8:
 509              		.cfi_restore_state
 270:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 510              		.loc 1 270 53 view .LVU154
 511 006c 00F12001 		add	r1, r0, #32
 512              	.LBB96:
 513              	.LBB92:
 495:Src/aspep.c   ****       {
 514              		.loc 1 495 7 is_stmt 1 view .LVU155
 504:Src/aspep.c   ****       {
 515              		.loc 1 504 12 view .LVU156
 511:Src/aspep.c   ****         pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 516              		.loc 1 511 9 view .LVU157
 511:Src/aspep.c   ****         pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 517              		.loc 1 511 35 is_stmt 0 view .LVU158
 518 0070 0323     		movs	r3, #3
 512:Src/aspep.c   ****       }
 519              		.loc 1 512 29 view .LVU159
 520 0072 8164     		str	r1, [r0, #72]
 511:Src/aspep.c   ****         pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 521              		.loc 1 511 35 view .LVU160
 522 0074 80F82430 		strb	r3, [r0, #36]
ARM GAS  /tmp/ccJS0l1g.s 			page 26


 512:Src/aspep.c   ****       }
 523              		.loc 1 512 9 is_stmt 1 view .LVU161
 515:Src/aspep.c   ****       pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, txBuffer, bufferLength);
 524              		.loc 1 515 7 view .LVU162
 525              	.LBB88:
 526              	.LBI88:
 196:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 527              		.loc 2 196 27 view .LVU163
 528              	.LBB89:
 198:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 529              		.loc 2 198 3 view .LVU164
 530              		.syntax unified
 531              	@ 198 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 532 0078 62B6     		cpsie i
 533              	@ 0 "" 2
 534              		.thumb
 535              		.syntax unified
 536              	.LBE89:
 537              	.LBE88:
 516:Src/aspep.c   ****     }
 538              		.loc 1 516 7 view .LVU165
 539 007a 0422     		movs	r2, #4
 540 007c 836D     		ldr	r3, [r0, #88]
 541 007e 4069     		ldr	r0, [r0, #20]
 542              	.LVL33:
 516:Src/aspep.c   ****     }
 543              		.loc 1 516 7 is_stmt 0 view .LVU166
 544              	.LBE92:
 545              	.LBE96:
 274:Src/aspep.c   **** 
 546              		.loc 1 274 1 view .LVU167
 547 0080 30BC     		pop	{r4, r5}
 548              	.LCFI9:
 549              		.cfi_restore 5
 550              		.cfi_restore 4
 551              		.cfi_def_cfa_offset 0
 552              	.LBB97:
 553              	.LBB93:
 516:Src/aspep.c   ****     }
 554              		.loc 1 516 7 view .LVU168
 555 0082 1847     		bx	r3	@ indirect register sibling call
 556              	.LVL34:
 557              	.L17:
 516:Src/aspep.c   ****     }
 558              		.loc 1 516 7 view .LVU169
 559              		.align	2
 560              	.L16:
 561 0084 00000000 		.word	.LANCHOR0
 562 0088 00000000 		.word	.LANCHOR1
 563              	.LBE93:
 564              	.LBE97:
 565              		.cfi_endproc
 566              	.LFE1442:
 568              		.section	.text.ASPEP_getBuffer,"ax",%progbits
 569              		.align	1
 570              		.p2align 2,,3
 571              		.global	ASPEP_getBuffer
ARM GAS  /tmp/ccJS0l1g.s 			page 27


 572              		.syntax unified
 573              		.thumb
 574              		.thumb_func
 575              		.fpu fpv4-sp-d16
 577              	ASPEP_getBuffer:
 578              	.LVL35:
 579              	.LFB1443:
 286:Src/aspep.c   ****   bool result = true;
 580              		.loc 1 286 1 is_stmt 1 view -0
 581              		.cfi_startproc
 582              		@ args = 0, pretend = 0, frame = 0
 583              		@ frame_needed = 0, uses_anonymous_args = 0
 584              		@ link register save eliminated.
 287:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 585              		.loc 1 287 3 view .LVU171
 296:Src/aspep.c   **** 
 586              		.loc 1 296 5 view .LVU172
 298:Src/aspep.c   ****     {
 587              		.loc 1 298 8 is_stmt 0 view .LVU173
 588 0000 0A2A     		cmp	r2, #10
 286:Src/aspep.c   ****   bool result = true;
 589              		.loc 1 286 1 view .LVU174
 590 0002 10B4     		push	{r4}
 591              	.LCFI10:
 592              		.cfi_def_cfa_offset 4
 593              		.cfi_offset 4, -4
 286:Src/aspep.c   ****   bool result = true;
 594              		.loc 1 286 1 view .LVU175
 595 0004 0346     		mov	r3, r0
 596              	.LVL36:
 298:Src/aspep.c   ****     {
 597              		.loc 1 298 5 is_stmt 1 view .LVU176
 298:Src/aspep.c   ****     {
 598              		.loc 1 298 8 is_stmt 0 view .LVU177
 599 0006 0BD0     		beq	.L27
 312:Src/aspep.c   ****       {
 600              		.loc 1 312 7 is_stmt 1 view .LVU178
 312:Src/aspep.c   ****       {
 601              		.loc 1 312 10 is_stmt 0 view .LVU179
 602 0008 90F83620 		ldrb	r2, [r0, #54]	@ zero_extendqisi2
 603              	.LVL37:
 312:Src/aspep.c   ****       {
 604              		.loc 1 312 10 view .LVU180
 605 000c 012A     		cmp	r2, #1
 606 000e 21D9     		bls	.L21
 312:Src/aspep.c   ****       {
 607              		.loc 1 312 53 discriminator 1 view .LVU181
 608 0010 90F83E20 		ldrb	r2, [r0, #62]	@ zero_extendqisi2
 609 0014 012A     		cmp	r2, #1
 610 0016 11D9     		bls	.L28
 611              	.L24:
 307:Src/aspep.c   ****       }
 612              		.loc 1 307 16 view .LVU182
 613 0018 0020     		movs	r0, #0
 614              	.LVL38:
 339:Src/aspep.c   ****       }
 615              		.loc 1 339 9 is_stmt 1 view .LVU183
ARM GAS  /tmp/ccJS0l1g.s 			page 28


 345:Src/aspep.c   **** }
 616              		.loc 1 345 3 view .LVU184
 346:Src/aspep.c   **** 
 617              		.loc 1 346 1 is_stmt 0 view .LVU185
 618 001a 5DF8044B 		ldr	r4, [sp], #4
 619              	.LCFI11:
 620              		.cfi_remember_state
 621              		.cfi_restore 4
 622              		.cfi_def_cfa_offset 0
 623 001e 7047     		bx	lr
 624              	.LVL39:
 625              	.L27:
 626              	.LCFI12:
 627              		.cfi_restore_state
 300:Src/aspep.c   ****       {
 628              		.loc 1 300 7 is_stmt 1 view .LVU186
 300:Src/aspep.c   ****       {
 629              		.loc 1 300 10 is_stmt 0 view .LVU187
 630 0020 90F82E20 		ldrb	r2, [r0, #46]	@ zero_extendqisi2
 631              	.LVL40:
 300:Src/aspep.c   ****       {
 632              		.loc 1 300 10 view .LVU188
 633 0024 012A     		cmp	r2, #1
 634 0026 F7D8     		bhi	.L24
 302:Src/aspep.c   ****         pHandle->syncBuffer.state = writeLock;
 635              		.loc 1 302 9 is_stmt 1 view .LVU189
 302:Src/aspep.c   ****         pHandle->syncBuffer.state = writeLock;
 636              		.loc 1 302 19 is_stmt 0 view .LVU190
 637 0028 826A     		ldr	r2, [r0, #40]
 303:Src/aspep.c   ****       }
 638              		.loc 1 303 35 view .LVU191
 639 002a 0124     		movs	r4, #1
 302:Src/aspep.c   ****         pHandle->syncBuffer.state = writeLock;
 640              		.loc 1 302 19 view .LVU192
 641 002c 0432     		adds	r2, r2, #4
 287:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 642              		.loc 1 287 8 view .LVU193
 643 002e 2046     		mov	r0, r4
 644              	.LVL41:
 302:Src/aspep.c   ****         pHandle->syncBuffer.state = writeLock;
 645              		.loc 1 302 17 view .LVU194
 646 0030 0A60     		str	r2, [r1]
 303:Src/aspep.c   ****       }
 647              		.loc 1 303 9 is_stmt 1 view .LVU195
 303:Src/aspep.c   ****       }
 648              		.loc 1 303 35 is_stmt 0 view .LVU196
 649 0032 83F82E40 		strb	r4, [r3, #46]
 650              	.LVL42:
 339:Src/aspep.c   ****       }
 651              		.loc 1 339 9 is_stmt 1 view .LVU197
 345:Src/aspep.c   **** }
 652              		.loc 1 345 3 view .LVU198
 346:Src/aspep.c   **** 
 653              		.loc 1 346 1 is_stmt 0 view .LVU199
 654 0036 5DF8044B 		ldr	r4, [sp], #4
 655              	.LCFI13:
 656              		.cfi_remember_state
ARM GAS  /tmp/ccJS0l1g.s 			page 29


 657              		.cfi_restore 4
 658              		.cfi_def_cfa_offset 0
 659 003a 7047     		bx	lr
 660              	.LVL43:
 661              	.L28:
 662              	.LCFI14:
 663              		.cfi_restore_state
 318:Src/aspep.c   ****         {
 664              		.loc 1 318 9 is_stmt 1 view .LVU200
 327:Src/aspep.c   ****         {
 665              		.loc 1 327 14 view .LVU201
 329:Src/aspep.c   ****           pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferB;
 666              		.loc 1 329 11 view .LVU202
 331:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 667              		.loc 1 331 21 is_stmt 0 view .LVU203
 668 003c 826B     		ldr	r2, [r0, #56]
 330:Src/aspep.c   ****           *buffer = &pHandle->asyncBufferB.buffer[ASPEP_HEADER_SIZE];
 669              		.loc 1 330 45 view .LVU204
 670 003e 03F13804 		add	r4, r3, #56
 329:Src/aspep.c   ****           pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferB;
 671              		.loc 1 329 39 view .LVU205
 672 0042 0120     		movs	r0, #1
 673              	.LVL44:
 331:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 674              		.loc 1 331 21 view .LVU206
 675 0044 0432     		adds	r2, r2, #4
 330:Src/aspep.c   ****           *buffer = &pHandle->asyncBufferB.buffer[ASPEP_HEADER_SIZE];
 676              		.loc 1 330 43 view .LVU207
 677 0046 1C64     		str	r4, [r3, #64]
 329:Src/aspep.c   ****           pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferB;
 678              		.loc 1 329 39 view .LVU208
 679 0048 83F83E00 		strb	r0, [r3, #62]
 330:Src/aspep.c   ****           *buffer = &pHandle->asyncBufferB.buffer[ASPEP_HEADER_SIZE];
 680              		.loc 1 330 11 is_stmt 1 view .LVU209
 331:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 681              		.loc 1 331 11 view .LVU210
 331:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 682              		.loc 1 331 19 is_stmt 0 view .LVU211
 683 004c 0A60     		str	r2, [r1]
 684              	.LVL45:
 339:Src/aspep.c   ****       }
 685              		.loc 1 339 9 is_stmt 1 view .LVU212
 345:Src/aspep.c   **** }
 686              		.loc 1 345 3 view .LVU213
 346:Src/aspep.c   **** 
 687              		.loc 1 346 1 is_stmt 0 view .LVU214
 688 004e 5DF8044B 		ldr	r4, [sp], #4
 689              	.LCFI15:
 690              		.cfi_remember_state
 691              		.cfi_restore 4
 692              		.cfi_def_cfa_offset 0
 693 0052 7047     		bx	lr
 694              	.LVL46:
 695              	.L21:
 696              	.LCFI16:
 697              		.cfi_restore_state
 318:Src/aspep.c   ****         {
ARM GAS  /tmp/ccJS0l1g.s 			page 30


 698              		.loc 1 318 9 is_stmt 1 view .LVU215
 320:Src/aspep.c   ****           pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferA;
 699              		.loc 1 320 11 view .LVU216
 322:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 700              		.loc 1 322 21 is_stmt 0 view .LVU217
 701 0054 026B     		ldr	r2, [r0, #48]
 321:Src/aspep.c   ****           *buffer = &pHandle->asyncBufferA.buffer[ASPEP_HEADER_SIZE];
 702              		.loc 1 321 45 view .LVU218
 703 0056 03F13004 		add	r4, r3, #48
 320:Src/aspep.c   ****           pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferA;
 704              		.loc 1 320 39 view .LVU219
 705 005a 0120     		movs	r0, #1
 706              	.LVL47:
 322:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 707              		.loc 1 322 21 view .LVU220
 708 005c 0432     		adds	r2, r2, #4
 321:Src/aspep.c   ****           *buffer = &pHandle->asyncBufferA.buffer[ASPEP_HEADER_SIZE];
 709              		.loc 1 321 43 view .LVU221
 710 005e 1C64     		str	r4, [r3, #64]
 320:Src/aspep.c   ****           pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferA;
 711              		.loc 1 320 39 view .LVU222
 712 0060 83F83600 		strb	r0, [r3, #54]
 321:Src/aspep.c   ****           *buffer = &pHandle->asyncBufferA.buffer[ASPEP_HEADER_SIZE];
 713              		.loc 1 321 11 is_stmt 1 view .LVU223
 322:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 714              		.loc 1 322 11 view .LVU224
 322:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 715              		.loc 1 322 19 is_stmt 0 view .LVU225
 716 0064 0A60     		str	r2, [r1]
 717              	.LVL48:
 339:Src/aspep.c   ****       }
 718              		.loc 1 339 9 is_stmt 1 view .LVU226
 345:Src/aspep.c   **** }
 719              		.loc 1 345 3 view .LVU227
 346:Src/aspep.c   **** 
 720              		.loc 1 346 1 is_stmt 0 view .LVU228
 721 0066 5DF8044B 		ldr	r4, [sp], #4
 722              	.LCFI17:
 723              		.cfi_restore 4
 724              		.cfi_def_cfa_offset 0
 725 006a 7047     		bx	lr
 726              		.cfi_endproc
 727              	.LFE1443:
 729              		.section	.text.ASPEP_sendPacket,"ax",%progbits
 730              		.align	1
 731              		.p2align 2,,3
 732              		.global	ASPEP_sendPacket
 733              		.syntax unified
 734              		.thumb
 735              		.thumb_func
 736              		.fpu fpv4-sp-d16
 738              	ASPEP_sendPacket:
 739              	.LVL49:
 740              	.LFB1445:
 405:Src/aspep.c   ****   uint8_t result = ASPEP_OK;
 741              		.loc 1 405 1 is_stmt 1 view -0
 742              		.cfi_startproc
ARM GAS  /tmp/ccJS0l1g.s 			page 31


 743              		@ args = 0, pretend = 0, frame = 0
 744              		@ frame_needed = 0, uses_anonymous_args = 0
 406:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 745              		.loc 1 406 3 view .LVU230
 415:Src/aspep.c   ****     uint32_t tmpHeader;
 746              		.loc 1 415 5 view .LVU231
 416:Src/aspep.c   ****     uint16_t txDataLengthTemp;
 747              		.loc 1 416 5 view .LVU232
 417:Src/aspep.c   ****     uint8_t *packet;
 748              		.loc 1 417 5 view .LVU233
 418:Src/aspep.c   **** 
 749              		.loc 1 418 5 view .LVU234
 420:Src/aspep.c   ****     ASPEP_Handle_t *pHandle = (ASPEP_Handle_t *)pSupHandle; //cstat !MISRAC2012-Rule-11.3
 750              		.loc 1 420 5 view .LVU235
 405:Src/aspep.c   ****   uint8_t result = ASPEP_OK;
 751              		.loc 1 405 1 is_stmt 0 view .LVU236
 752 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 753              	.LCFI18:
 754              		.cfi_def_cfa_offset 24
 755              		.cfi_offset 3, -24
 756              		.cfi_offset 4, -20
 757              		.cfi_offset 5, -16
 758              		.cfi_offset 6, -12
 759              		.cfi_offset 7, -8
 760              		.cfi_offset 14, -4
 405:Src/aspep.c   ****   uint8_t result = ASPEP_OK;
 761              		.loc 1 405 1 view .LVU237
 762 0002 0446     		mov	r4, r0
 423:Src/aspep.c   ****     {
 763              		.loc 1 423 8 view .LVU238
 764 0004 90F86400 		ldrb	r0, [r0, #100]	@ zero_extendqisi2
 765              	.LVL50:
 421:Src/aspep.c   **** 
 766              		.loc 1 421 5 is_stmt 1 view .LVU239
 423:Src/aspep.c   ****     {
 767              		.loc 1 423 5 view .LVU240
 423:Src/aspep.c   ****     {
 768              		.loc 1 423 8 is_stmt 0 view .LVU241
 769 0008 0228     		cmp	r0, #2
 770 000a 01D0     		beq	.L48
 457:Src/aspep.c   ****     }
 771              		.loc 1 457 14 view .LVU242
 772 000c 0220     		movs	r0, #2
 773              	.LVL51:
 462:Src/aspep.c   **** }
 774              		.loc 1 462 3 is_stmt 1 view .LVU243
 463:Src/aspep.c   **** 
 775              		.loc 1 463 1 is_stmt 0 view .LVU244
 776 000e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 777              	.LVL52:
 778              	.L48:
 427:Src/aspep.c   ****       header = (uint32_t *)txBuffer; //cstat !MISRAC2012-Rule-11.5
 779              		.loc 1 427 7 is_stmt 1 view .LVU245
 428:Src/aspep.c   ****       header--; /* Header ues 4*8 bits on top of txBuffer*/
 780              		.loc 1 428 7 view .LVU246
 429:Src/aspep.c   ****       tmpHeader = ((uint32_t)((uint32_t)txDataLengthTemp << (uint32_t)4) | (uint32_t)syncAsync);
 781              		.loc 1 429 7 view .LVU247
ARM GAS  /tmp/ccJS0l1g.s 			page 32


 430:Src/aspep.c   ****       *header = tmpHeader;
 782              		.loc 1 430 7 view .LVU248
 431:Src/aspep.c   ****       if (1U == pHandle->Capabilities.DATA_CRC)
 783              		.loc 1 431 7 view .LVU249
 430:Src/aspep.c   ****       *header = tmpHeader;
 784              		.loc 1 430 17 is_stmt 0 view .LVU250
 785 0010 43EA0210 		orr	r0, r3, r2, lsl #4
 431:Src/aspep.c   ****       if (1U == pHandle->Capabilities.DATA_CRC)
 786              		.loc 1 431 15 view .LVU251
 787 0014 41F8040C 		str	r0, [r1, #-4]
 432:Src/aspep.c   ****       {
 788              		.loc 1 432 7 is_stmt 1 view .LVU252
 432:Src/aspep.c   ****       {
 789              		.loc 1 432 10 is_stmt 0 view .LVU253
 790 0018 94F86C00 		ldrb	r0, [r4, #108]	@ zero_extendqisi2
 791 001c 0128     		cmp	r0, #1
 792 001e 06D1     		bne	.L31
 435:Src/aspep.c   ****         packet[txDataLengthTemp + 1U] = (uint8_t)0xFE; /* Dummy CRC */
 793              		.loc 1 435 9 is_stmt 1 view .LVU254
 436:Src/aspep.c   ****         txDataLengthTemp += (uint16_t)ASPEP_DATACRC_SIZE;
 794              		.loc 1 436 39 is_stmt 0 view .LVU255
 795 0020 8818     		adds	r0, r1, r2
 435:Src/aspep.c   ****         packet[txDataLengthTemp + 1U] = (uint8_t)0xFE; /* Dummy CRC */
 796              		.loc 1 435 34 view .LVU256
 797 0022 CA25     		movs	r5, #202
 798 0024 8D54     		strb	r5, [r1, r2]
 436:Src/aspep.c   ****         txDataLengthTemp += (uint16_t)ASPEP_DATACRC_SIZE;
 799              		.loc 1 436 9 is_stmt 1 view .LVU257
 437:Src/aspep.c   ****       }
 800              		.loc 1 437 26 is_stmt 0 view .LVU258
 801 0026 961C     		adds	r6, r2, #2
 436:Src/aspep.c   ****         txDataLengthTemp += (uint16_t)ASPEP_DATACRC_SIZE;
 802              		.loc 1 436 39 view .LVU259
 803 0028 FE25     		movs	r5, #254
 437:Src/aspep.c   ****       }
 804              		.loc 1 437 26 view .LVU260
 805 002a B2B2     		uxth	r2, r6
 806              	.LVL53:
 436:Src/aspep.c   ****         txDataLengthTemp += (uint16_t)ASPEP_DATACRC_SIZE;
 807              		.loc 1 436 39 view .LVU261
 808 002c 4570     		strb	r5, [r0, #1]
 437:Src/aspep.c   ****       }
 809              		.loc 1 437 9 is_stmt 1 view .LVU262
 810              	.LVL54:
 811              	.L31:
 439:Src/aspep.c   ****       {
 812              		.loc 1 439 7 view .LVU263
 439:Src/aspep.c   ****       {
 813              		.loc 1 439 10 is_stmt 0 view .LVU264
 814 002e 0A2B     		cmp	r3, #10
 815 0030 03D1     		bne	.L32
 441:Src/aspep.c   ****         {
 816              		.loc 1 441 9 is_stmt 1 view .LVU265
 441:Src/aspep.c   ****         {
 817              		.loc 1 441 12 is_stmt 0 view .LVU266
 818 0032 207C     		ldrb	r0, [r4, #16]	@ zero_extendqisi2
 819 0034 78B3     		cbz	r0, .L42
ARM GAS  /tmp/ccJS0l1g.s 			page 33


 443:Src/aspep.c   ****         }
 820              		.loc 1 443 11 is_stmt 1 view .LVU267
 443:Src/aspep.c   ****         }
 821              		.loc 1 443 43 is_stmt 0 view .LVU268
 822 0036 0020     		movs	r0, #0
 823 0038 2074     		strb	r0, [r4, #16]
 450:Src/aspep.c   ****       {
 824              		.loc 1 450 7 is_stmt 1 view .LVU269
 825              	.L32:
 826              	.LBB108:
 827              	.LBB109:
 828              	.LBB110:
 829              	.LBB111:
 121:Src/aspep.c   **** 
 830              		.loc 1 121 12 is_stmt 0 view .LVU270
 831 003a 51F8045C 		ldr	r5, [r1, #-4]
 126:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 832              		.loc 1 126 7 view .LVU271
 833 003e DFF8CCC0 		ldr	ip, .L55+4
 129:Src/aspep.c   **** #else /* CRC4_PER_NIBBLE */
 834              		.loc 1 129 7 view .LVU272
 835 0042 314F     		ldr	r7, .L55
 126:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 836              		.loc 1 126 26 view .LVU273
 837 0044 E8B2     		uxtb	r0, r5
 124:Src/aspep.c   **** 
 838              		.loc 1 124 10 view .LVU274
 839 0046 25F07046 		bic	r6, r5, #-268435456
 127:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 840              		.loc 1 127 26 view .LVU275
 841 004a 1CF80000 		ldrb	r0, [ip, r0]	@ zero_extendqisi2
 842 004e 80EA1620 		eor	r0, r0, r6, lsr #8
 843 0052 C0B2     		uxtb	r0, r0
 844              	.LBE111:
 845              	.LBE110:
 846              	.LBE109:
 847              	.LBE108:
 452:Src/aspep.c   ****       }
 848              		.loc 1 452 18 view .LVU276
 849 0054 0432     		adds	r2, r2, #4
 850              	.LVL55:
 851              	.LBB133:
 852              	.LBB124:
 853              	.LBB115:
 854              	.LBB112:
 128:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 855              		.loc 1 128 26 view .LVU277
 856 0056 1CF80000 		ldrb	r0, [ip, r0]	@ zero_extendqisi2
 857 005a 80EA1640 		eor	r0, r0, r6, lsr #16
 858 005e C0B2     		uxtb	r0, r0
 859              	.LBE112:
 860              	.LBE115:
 861              	.LBE124:
 862              	.LBE133:
 452:Src/aspep.c   ****       }
 863              		.loc 1 452 18 view .LVU278
 864 0060 92B2     		uxth	r2, r2
ARM GAS  /tmp/ccJS0l1g.s 			page 34


 865              	.LBB134:
 866              	.LBB125:
 867              	.LBB116:
 868              	.LBB113:
 129:Src/aspep.c   **** #else /* CRC4_PER_NIBBLE */
 869              		.loc 1 129 26 view .LVU279
 870 0062 1CF80000 		ldrb	r0, [ip, r0]	@ zero_extendqisi2
 871 0066 80EA1666 		eor	r6, r0, r6, lsr #24
 872              	.LBE113:
 873              	.LBE116:
 874              	.LBE125:
 875              	.LBE134:
 429:Src/aspep.c   ****       tmpHeader = ((uint32_t)((uint32_t)txDataLengthTemp << (uint32_t)4) | (uint32_t)syncAsync);
 876              		.loc 1 429 13 view .LVU280
 877 006a 081F     		subs	r0, r1, #4
 452:Src/aspep.c   ****       }
 878              		.loc 1 452 9 is_stmt 1 view .LVU281
 879              	.LVL56:
 880              	.LBB135:
 881              	.LBI108:
 479:Src/aspep.c   **** {
 882              		.loc 1 479 9 view .LVU282
 883              	.LBB126:
 481:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 884              		.loc 1 481 3 view .LVU283
 491:Src/aspep.c   ****     __disable_irq(); /*TODO: Disable High frequency task is enough */
 885              		.loc 1 491 5 view .LVU284
 886              	.LBB117:
 887              	.LBI110:
 118:Src/aspep.c   **** {
 888              		.loc 1 118 13 view .LVU285
 889              	.LBB114:
 120:Src/aspep.c   ****   uint32_t header = *headerPtr;
 890              		.loc 1 120 3 view .LVU286
 121:Src/aspep.c   **** 
 891              		.loc 1 121 3 view .LVU287
 124:Src/aspep.c   **** 
 892              		.loc 1 124 3 view .LVU288
 126:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 893              		.loc 1 126 3 view .LVU289
 127:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 894              		.loc 1 127 3 view .LVU290
 128:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 895              		.loc 1 128 3 view .LVU291
 129:Src/aspep.c   **** #else /* CRC4_PER_NIBBLE */
 896              		.loc 1 129 3 view .LVU292
 140:Src/aspep.c   **** 
 897              		.loc 1 140 3 view .LVU293
 140:Src/aspep.c   **** 
 898              		.loc 1 140 17 is_stmt 0 view .LVU294
 899 006c BE5D     		ldrb	r6, [r7, r6]	@ zero_extendqisi2
 900              	.LVL57:
 140:Src/aspep.c   **** 
 901              		.loc 1 140 14 view .LVU295
 902 006e 45EA0675 		orr	r5, r5, r6, lsl #28
 903              	.LVL58:
 140:Src/aspep.c   **** 
ARM GAS  /tmp/ccJS0l1g.s 			page 35


 904              		.loc 1 140 14 view .LVU296
 905 0072 41F8045C 		str	r5, [r1, #-4]
 906              	.LVL59:
 140:Src/aspep.c   **** 
 907              		.loc 1 140 14 view .LVU297
 908              	.LBE114:
 909              	.LBE117:
 492:Src/aspep.c   ****     if (NULL == pHandle->lockBuffer) /* Communication Ip free to send data*/
 910              		.loc 1 492 5 is_stmt 1 view .LVU298
 911              	.LBB118:
 912              	.LBI118:
 207:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 913              		.loc 2 207 27 view .LVU299
 914              	.LBB119:
 915              		.loc 2 209 3 view .LVU300
 916              		.syntax unified
 917              	@ 209 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 918 0076 72B6     		cpsid i
 919              	@ 0 "" 2
 920              		.thumb
 921              		.syntax unified
 922              	.LBE119:
 923              	.LBE118:
 493:Src/aspep.c   ****     {
 924              		.loc 1 493 5 view .LVU301
 493:Src/aspep.c   ****     {
 925              		.loc 1 493 8 is_stmt 0 view .LVU302
 926 0078 A16C     		ldr	r1, [r4, #72]
 927              	.LVL60:
 493:Src/aspep.c   ****     {
 928              		.loc 1 493 8 view .LVU303
 929 007a D1B1     		cbz	r1, .L49
 520:Src/aspep.c   ****       /* Lock buffer can be freed here */
 930              		.loc 1 520 7 is_stmt 1 view .LVU304
 931              	.LBB120:
 932              	.LBI120:
 196:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 933              		.loc 2 196 27 view .LVU305
 934              	.LBB121:
 198:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 935              		.loc 2 198 3 view .LVU306
 936              		.syntax unified
 937              	@ 198 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 938 007c 62B6     		cpsie i
 939              	@ 0 "" 2
 940              		.thumb
 941              		.syntax unified
 942              	.LBE121:
 943              	.LBE120:
 522:Src/aspep.c   ****       {
 944              		.loc 1 522 7 view .LVU307
 522:Src/aspep.c   ****       {
 945              		.loc 1 522 10 is_stmt 0 view .LVU308
 946 007e 092B     		cmp	r3, #9
 947 0080 0BD0     		beq	.L50
 548:Src/aspep.c   ****       {
 948              		.loc 1 548 12 is_stmt 1 view .LVU309
ARM GAS  /tmp/ccJS0l1g.s 			page 36


 548:Src/aspep.c   ****       {
 949              		.loc 1 548 15 is_stmt 0 view .LVU310
 950 0082 0A2B     		cmp	r3, #10
 951 0084 2BD0     		beq	.L51
 560:Src/aspep.c   ****       {
 952              		.loc 1 560 12 is_stmt 1 view .LVU311
 560:Src/aspep.c   ****       {
 953              		.loc 1 560 14 is_stmt 0 view .LVU312
 954 0086 83BB     		cbnz	r3, .L45
 562:Src/aspep.c   ****         {
 955              		.loc 1 562 9 is_stmt 1 view .LVU313
 562:Src/aspep.c   ****         {
 956              		.loc 1 562 32 is_stmt 0 view .LVU314
 957 0088 94F82400 		ldrb	r0, [r4, #36]	@ zero_extendqisi2
 958              	.LVL61:
 562:Src/aspep.c   ****         {
 959              		.loc 1 562 12 view .LVU315
 960 008c 58BB     		cbnz	r0, .L46
 568:Src/aspep.c   ****         }
 961              		.loc 1 568 11 is_stmt 1 view .LVU316
 568:Src/aspep.c   ****         }
 962              		.loc 1 568 37 is_stmt 0 view .LVU317
 963 008e 0223     		movs	r3, #2
 964              	.LVL62:
 568:Src/aspep.c   ****         }
 965              		.loc 1 568 37 view .LVU318
 966 0090 84F82430 		strb	r3, [r4, #36]
 967              	.LVL63:
 568:Src/aspep.c   ****         }
 968              		.loc 1 568 37 view .LVU319
 969              	.LBE126:
 970              	.LBE135:
 462:Src/aspep.c   **** }
 971              		.loc 1 462 3 is_stmt 1 view .LVU320
 463:Src/aspep.c   **** 
 972              		.loc 1 463 1 is_stmt 0 view .LVU321
 973 0094 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 974              	.LVL64:
 975              	.L42:
 447:Src/aspep.c   ****         }
 976              		.loc 1 447 18 view .LVU322
 977 0096 0120     		movs	r0, #1
 978              	.LVL65:
 462:Src/aspep.c   **** }
 979              		.loc 1 462 3 is_stmt 1 view .LVU323
 463:Src/aspep.c   **** 
 980              		.loc 1 463 1 is_stmt 0 view .LVU324
 981 0098 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 982              	.LVL66:
 983              	.L50:
 984              	.LBB136:
 985              	.LBB127:
 525:Src/aspep.c   ****         {
 986              		.loc 1 525 9 is_stmt 1 view .LVU325
 533:Src/aspep.c   ****         {
 987              		.loc 1 533 12 is_stmt 0 view .LVU326
 988 009a D4E91035 		ldrd	r3, r5, [r4, #64]
ARM GAS  /tmp/ccJS0l1g.s 			page 37


 989              	.LVL67:
 525:Src/aspep.c   ****         {
 990              		.loc 1 525 12 view .LVU327
 991 009e 1968     		ldr	r1, [r3]
 527:Src/aspep.c   ****         }
 992              		.loc 1 527 18 view .LVU328
 993 00a0 8842     		cmp	r0, r1
 994 00a2 14BF     		ite	ne
 995 00a4 0320     		movne	r0, #3
 996 00a6 0020     		moveq	r0, #0
 997              	.LVL68:
 532:Src/aspep.c   ****         if (NULL == pHandle->asyncNextBuffer)
 998              		.loc 1 532 9 is_stmt 1 view .LVU329
 533:Src/aspep.c   ****         {
 999              		.loc 1 533 9 view .LVU330
 533:Src/aspep.c   ****         {
 1000              		.loc 1 533 12 is_stmt 0 view .LVU331
 1001 00a8 65B3     		cbz	r5, .L52
 1002              	.L39:
 541:Src/aspep.c   ****         pHandle->lastRequestedAsyncBuff->state = pending;
 1003              		.loc 1 541 9 is_stmt 1 view .LVU332
 542:Src/aspep.c   ****         pHandle->lastRequestedAsyncBuff->length = bufferLength;
 1004              		.loc 1 542 9 view .LVU333
 542:Src/aspep.c   ****         pHandle->lastRequestedAsyncBuff->length = bufferLength;
 1005              		.loc 1 542 48 is_stmt 0 view .LVU334
 1006 00aa 0221     		movs	r1, #2
 543:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 1007              		.loc 1 543 49 view .LVU335
 1008 00ac 9A80     		strh	r2, [r3, #4]	@ movhi
 542:Src/aspep.c   ****         pHandle->lastRequestedAsyncBuff->length = bufferLength;
 1009              		.loc 1 542 48 view .LVU336
 1010 00ae 9971     		strb	r1, [r3, #6]
 543:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 1011              		.loc 1 543 9 is_stmt 1 view .LVU337
 1012              	.LVL69:
 543:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 1013              		.loc 1 543 9 is_stmt 0 view .LVU338
 1014              	.LBE127:
 1015              	.LBE136:
 462:Src/aspep.c   **** }
 1016              		.loc 1 462 3 is_stmt 1 view .LVU339
 463:Src/aspep.c   **** 
 1017              		.loc 1 463 1 is_stmt 0 view .LVU340
 1018 00b0 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1019              	.LVL70:
 1020              	.L49:
 1021              	.LBB137:
 1022              	.LBB128:
 495:Src/aspep.c   ****       {
 1023              		.loc 1 495 7 is_stmt 1 view .LVU341
 495:Src/aspep.c   ****       {
 1024              		.loc 1 495 10 is_stmt 0 view .LVU342
 1025 00b2 092B     		cmp	r3, #9
 1026 00b4 21D0     		beq	.L53
 504:Src/aspep.c   ****       {
 1027              		.loc 1 504 12 is_stmt 1 view .LVU343
 504:Src/aspep.c   ****       {
ARM GAS  /tmp/ccJS0l1g.s 			page 38


 1028              		.loc 1 504 15 is_stmt 0 view .LVU344
 1029 00b6 0A2B     		cmp	r3, #10
 506:Src/aspep.c   ****         pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
 1030              		.loc 1 506 9 is_stmt 1 view .LVU345
 506:Src/aspep.c   ****         pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
 1031              		.loc 1 506 35 is_stmt 0 view .LVU346
 1032 00b8 4FF00301 		mov	r1, #3
 507:Src/aspep.c   ****       }
 1033              		.loc 1 507 39 view .LVU347
 1034 00bc 0BBF     		itete	eq
 1035 00be 04F12803 		addeq	r3, r4, #40
 1036              	.LVL71:
 512:Src/aspep.c   ****       }
 1037              		.loc 1 512 39 view .LVU348
 1038 00c2 04F12003 		addne	r3, r4, #32
 506:Src/aspep.c   ****         pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
 1039              		.loc 1 506 35 view .LVU349
 1040 00c6 84F82E10 		strbeq	r1, [r4, #46]
 511:Src/aspep.c   ****         pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 1041              		.loc 1 511 9 is_stmt 1 view .LVU350
 511:Src/aspep.c   ****         pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 1042              		.loc 1 511 35 is_stmt 0 view .LVU351
 1043 00ca 84F82410 		strbne	r1, [r4, #36]
 512:Src/aspep.c   ****       }
 1044              		.loc 1 512 9 is_stmt 1 view .LVU352
 512:Src/aspep.c   ****       }
 1045              		.loc 1 512 29 is_stmt 0 view .LVU353
 1046 00ce A364     		str	r3, [r4, #72]
 1047              	.L35:
 515:Src/aspep.c   ****       pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, txBuffer, bufferLength);
 1048              		.loc 1 515 7 is_stmt 1 view .LVU354
 1049              	.LBB122:
 1050              	.LBI122:
 196:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 1051              		.loc 2 196 27 view .LVU355
 1052              	.LBB123:
 198:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 1053              		.loc 2 198 3 view .LVU356
 1054              		.syntax unified
 1055              	@ 198 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1056 00d0 62B6     		cpsie i
 1057              	@ 0 "" 2
 1058              		.thumb
 1059              		.syntax unified
 1060              	.LBE123:
 1061              	.LBE122:
 516:Src/aspep.c   ****     }
 1062              		.loc 1 516 7 view .LVU357
 1063 00d2 0146     		mov	r1, r0
 1064 00d4 A36D     		ldr	r3, [r4, #88]
 1065 00d6 6069     		ldr	r0, [r4, #20]
 1066 00d8 9847     		blx	r3
 1067              	.LVL72:
 481:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 1068              		.loc 1 481 11 is_stmt 0 view .LVU358
 1069 00da 0020     		movs	r0, #0
 1070              	.LVL73:
ARM GAS  /tmp/ccJS0l1g.s 			page 39


 481:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 1071              		.loc 1 481 11 view .LVU359
 1072              	.LBE128:
 1073              	.LBE137:
 462:Src/aspep.c   **** }
 1074              		.loc 1 462 3 is_stmt 1 view .LVU360
 463:Src/aspep.c   **** 
 1075              		.loc 1 463 1 is_stmt 0 view .LVU361
 1076 00dc F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1077              	.LVL74:
 1078              	.L51:
 1079              	.LBB138:
 1080              	.LBB129:
 550:Src/aspep.c   ****         {
 1081              		.loc 1 550 9 is_stmt 1 view .LVU362
 550:Src/aspep.c   ****         {
 1082              		.loc 1 550 12 is_stmt 0 view .LVU363
 1083 00de 94F82E30 		ldrb	r3, [r4, #46]	@ zero_extendqisi2
 1084              	.LVL75:
 550:Src/aspep.c   ****         {
 1085              		.loc 1 550 12 view .LVU364
 1086 00e2 012B     		cmp	r3, #1
 1087 00e4 03D0     		beq	.L54
 1088              	.L46:
 552:Src/aspep.c   ****         }
 1089              		.loc 1 552 18 view .LVU365
 1090 00e6 0320     		movs	r0, #3
 1091              	.LVL76:
 552:Src/aspep.c   ****         }
 1092              		.loc 1 552 18 view .LVU366
 1093              	.LBE129:
 1094              	.LBE138:
 462:Src/aspep.c   **** }
 1095              		.loc 1 462 3 is_stmt 1 view .LVU367
 463:Src/aspep.c   **** 
 1096              		.loc 1 463 1 is_stmt 0 view .LVU368
 1097 00e8 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1098              	.LVL77:
 1099              	.L45:
 1100              	.LBB139:
 1101              	.LBB130:
 481:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 1102              		.loc 1 481 11 view .LVU369
 1103 00ea 0020     		movs	r0, #0
 1104              	.LVL78:
 481:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 1105              		.loc 1 481 11 view .LVU370
 1106              	.LBE130:
 1107              	.LBE139:
 462:Src/aspep.c   **** }
 1108              		.loc 1 462 3 is_stmt 1 view .LVU371
 463:Src/aspep.c   **** 
 1109              		.loc 1 463 1 is_stmt 0 view .LVU372
 1110 00ec F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1111              	.LVL79:
 1112              	.L54:
 1113              	.LBB140:
ARM GAS  /tmp/ccJS0l1g.s 			page 40


 1114              	.LBB131:
 556:Src/aspep.c   ****           pHandle->syncBuffer.length = bufferLength;
 1115              		.loc 1 556 11 is_stmt 1 view .LVU373
 556:Src/aspep.c   ****           pHandle->syncBuffer.length = bufferLength;
 1116              		.loc 1 556 37 is_stmt 0 view .LVU374
 1117 00ee 0223     		movs	r3, #2
 557:Src/aspep.c   ****         }
 1118              		.loc 1 557 38 view .LVU375
 1119 00f0 A285     		strh	r2, [r4, #44]	@ movhi
 556:Src/aspep.c   ****           pHandle->syncBuffer.length = bufferLength;
 1120              		.loc 1 556 37 view .LVU376
 1121 00f2 84F82E30 		strb	r3, [r4, #46]
 557:Src/aspep.c   ****         }
 1122              		.loc 1 557 11 is_stmt 1 view .LVU377
 481:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 1123              		.loc 1 481 11 is_stmt 0 view .LVU378
 1124 00f6 0020     		movs	r0, #0
 1125              	.LVL80:
 481:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 1126              		.loc 1 481 11 view .LVU379
 1127              	.LBE131:
 1128              	.LBE140:
 462:Src/aspep.c   **** }
 1129              		.loc 1 462 3 is_stmt 1 view .LVU380
 463:Src/aspep.c   **** 
 1130              		.loc 1 463 1 is_stmt 0 view .LVU381
 1131 00f8 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1132              	.LVL81:
 1133              	.L53:
 1134              	.LBB141:
 1135              	.LBB132:
 498:Src/aspep.c   ****         pHandle->lockBuffer = (void *)pHandle->lastRequestedAsyncBuff;
 1136              		.loc 1 498 9 is_stmt 1 view .LVU382
 498:Src/aspep.c   ****         pHandle->lockBuffer = (void *)pHandle->lastRequestedAsyncBuff;
 1137              		.loc 1 498 16 is_stmt 0 view .LVU383
 1138 00fa 236C     		ldr	r3, [r4, #64]
 1139              	.LVL82:
 498:Src/aspep.c   ****         pHandle->lockBuffer = (void *)pHandle->lastRequestedAsyncBuff;
 1140              		.loc 1 498 48 view .LVU384
 1141 00fc 0321     		movs	r1, #3
 1142 00fe 9971     		strb	r1, [r3, #6]
 499:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 1143              		.loc 1 499 9 is_stmt 1 view .LVU385
 499:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 1144              		.loc 1 499 29 is_stmt 0 view .LVU386
 1145 0100 A364     		str	r3, [r4, #72]
 1146 0102 E5E7     		b	.L35
 1147              	.LVL83:
 1148              	.L52:
 536:Src/aspep.c   ****         }
 1149              		.loc 1 536 11 is_stmt 1 view .LVU387
 536:Src/aspep.c   ****         }
 1150              		.loc 1 536 36 is_stmt 0 view .LVU388
 1151 0104 6364     		str	r3, [r4, #68]
 1152 0106 D0E7     		b	.L39
 1153              	.L56:
 1154              		.align	2
ARM GAS  /tmp/ccJS0l1g.s 			page 41


 1155              	.L55:
 1156 0108 00000000 		.word	.LANCHOR1
 1157 010c 00000000 		.word	.LANCHOR0
 1158              	.LBE132:
 1159              	.LBE141:
 1160              		.cfi_endproc
 1161              	.LFE1445:
 1163              		.section	.text.ASPEP_HWDataTransmittedIT,"ax",%progbits
 1164              		.align	1
 1165              		.p2align 2,,3
 1166              		.global	ASPEP_HWDataTransmittedIT
 1167              		.syntax unified
 1168              		.thumb
 1169              		.thumb_func
 1170              		.fpu fpv4-sp-d16
 1172              	ASPEP_HWDataTransmittedIT:
 1173              	.LVL84:
 1174              	.LFB1447:
 580:Src/aspep.c   **** }
 581:Src/aspep.c   **** 
 582:Src/aspep.c   **** /**
 583:Src/aspep.c   ****   * @brief  Frees previously locked buffer and/or locks the next pending buffer. Once locked, sends
 584:Src/aspep.c   ****   *
 585:Src/aspep.c   ****   * Called as soon as previous packet transfer is completed, pHandle->lockBuffer is set before pack
 586:Src/aspep.c   ****   * Therefore, there is no need to protect this ISR against another higher priority ISR (HF Task).
 587:Src/aspep.c   ****   *
 588:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 589:Src/aspep.c   ****   */
 590:Src/aspep.c   **** void ASPEP_HWDataTransmittedIT(ASPEP_Handle_t *pHandle)
 591:Src/aspep.c   **** {
 1175              		.loc 1 591 1 is_stmt 1 view -0
 1176              		.cfi_startproc
 1177              		@ args = 0, pretend = 0, frame = 0
 1178              		@ frame_needed = 0, uses_anonymous_args = 0
 592:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 593:Src/aspep.c   ****   if (NULL == pHandle)
 594:Src/aspep.c   ****   {
 595:Src/aspep.c   ****     /* Nothing to do */
 596:Src/aspep.c   ****   }
 597:Src/aspep.c   ****   else
 598:Src/aspep.c   ****   {
 599:Src/aspep.c   **** #endif
 600:Src/aspep.c   ****     /* First free previous readLock buffer */
 601:Src/aspep.c   ****     if (pHandle->ctrlBuffer.state == readLock)
 1179              		.loc 1 601 5 view .LVU390
 591:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 1180              		.loc 1 591 1 is_stmt 0 view .LVU391
 1181 0000 38B5     		push	{r3, r4, r5, lr}
 1182              	.LCFI19:
 1183              		.cfi_def_cfa_offset 16
 1184              		.cfi_offset 3, -16
 1185              		.cfi_offset 4, -12
 1186              		.cfi_offset 5, -8
 1187              		.cfi_offset 14, -4
 1188              		.loc 1 601 28 view .LVU392
 1189 0002 90F82430 		ldrb	r3, [r0, #36]	@ zero_extendqisi2
 1190              		.loc 1 601 8 view .LVU393
ARM GAS  /tmp/ccJS0l1g.s 			page 42


 1191 0006 032B     		cmp	r3, #3
 591:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 1192              		.loc 1 591 1 view .LVU394
 1193 0008 0446     		mov	r4, r0
 1194              		.loc 1 601 8 view .LVU395
 1195 000a 13D0     		beq	.L73
 1196              	.LBB142:
 602:Src/aspep.c   ****     {
 603:Src/aspep.c   ****       pHandle->ctrlBuffer.state = available;
 604:Src/aspep.c   ****     }
 605:Src/aspep.c   ****     else /* if previous buffer was not ASPEP_CTRL, then the buffer locked is a MCTL_Buff_t */
 606:Src/aspep.c   ****     {
 607:Src/aspep.c   ****       MCTL_Buff_t *tempBuff = (MCTL_Buff_t *)pHandle->lockBuffer; //cstat !MISRAC2012-Rule-11.5
 1197              		.loc 1 607 7 is_stmt 1 view .LVU396
 1198              	.LVL85:
 608:Src/aspep.c   ****       tempBuff->state = available;
 1199              		.loc 1 608 7 view .LVU397
 1200              		.loc 1 608 23 is_stmt 0 view .LVU398
 1201 000c 826C     		ldr	r2, [r0, #72]
 1202 000e 0021     		movs	r1, #0
 1203 0010 9171     		strb	r1, [r2, #6]
 1204              	.LBE142:
 609:Src/aspep.c   ****     }
 610:Src/aspep.c   ****     if (pHandle->syncBuffer.state == pending)
 1205              		.loc 1 610 5 is_stmt 1 view .LVU399
 1206              		.loc 1 610 8 is_stmt 0 view .LVU400
 1207 0012 90F82E20 		ldrb	r2, [r0, #46]	@ zero_extendqisi2
 1208 0016 022A     		cmp	r2, #2
 1209 0018 13D0     		beq	.L61
 611:Src/aspep.c   ****     {
 612:Src/aspep.c   ****       pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
 613:Src/aspep.c   ****       pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->syncBuffer.buffer, pHandle->syncBuffer.l
 614:Src/aspep.c   ****       pHandle->syncBuffer.state = readLock;
 615:Src/aspep.c   ****     }
 616:Src/aspep.c   ****     /* Second prepare transfer of pending buffer */
 617:Src/aspep.c   ****     else if (pHandle->ctrlBuffer.state == pending)
 1210              		.loc 1 617 10 is_stmt 1 view .LVU401
 1211              		.loc 1 617 13 is_stmt 0 view .LVU402
 1212 001a 022B     		cmp	r3, #2
 1213 001c 1DD1     		bne	.L59
 618:Src/aspep.c   ****     {
 619:Src/aspep.c   ****       pHandle->lockBuffer = (void *)(&pHandle ->ctrlBuffer);
 1214              		.loc 1 619 7 is_stmt 1 view .LVU403
 1215              		.loc 1 619 38 is_stmt 0 view .LVU404
 1216 001e 00F12001 		add	r1, r0, #32
 620:Src/aspep.c   ****       pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->ctrlBuffer.buffer, ASPEP_CTRL_SIZE);
 1217              		.loc 1 620 7 view .LVU405
 1218 0022 836D     		ldr	r3, [r0, #88]
 619:Src/aspep.c   ****       pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->ctrlBuffer.buffer, ASPEP_CTRL_SIZE);
 1219              		.loc 1 619 27 view .LVU406
 1220 0024 8164     		str	r1, [r0, #72]
 1221              	.LVL86:
 1222              		.loc 1 620 7 is_stmt 1 view .LVU407
 1223 0026 0422     		movs	r2, #4
 1224 0028 4069     		ldr	r0, [r0, #20]
 1225              	.LVL87:
 1226              		.loc 1 620 7 is_stmt 0 view .LVU408
ARM GAS  /tmp/ccJS0l1g.s 			page 43


 1227 002a 9847     		blx	r3
 1228              	.LVL88:
 621:Src/aspep.c   ****       pHandle->ctrlBuffer.state = readLock;
 1229              		.loc 1 621 7 is_stmt 1 view .LVU409
 1230              		.loc 1 621 33 is_stmt 0 view .LVU410
 1231 002c 0323     		movs	r3, #3
 1232 002e 84F82430 		strb	r3, [r4, #36]
 622:Src/aspep.c   ****     }
 623:Src/aspep.c   ****     else
 624:Src/aspep.c   ****     {
 625:Src/aspep.c   ****       __disable_irq();
 626:Src/aspep.c   ****       if (pHandle->asyncNextBuffer != NULL)
 627:Src/aspep.c   ****       {
 628:Src/aspep.c   ****         pHandle->lockBuffer = (void *)pHandle->asyncNextBuffer;
 629:Src/aspep.c   ****         pHandle->asyncNextBuffer->state = readLock;
 630:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 631:Src/aspep.c   ****         pHandle->asyncNextBuffer->SentNumber++;
 632:Src/aspep.c   **** #endif
 633:Src/aspep.c   ****         pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->asyncNextBuffer->buffer, pHandle->asyn
 634:Src/aspep.c   ****         /* If one Async buffer is still pending, assign it to the asyncNextBuffer pointer*/
 635:Src/aspep.c   ****         if ((pHandle->asyncBufferA.state == pending) || (pHandle->asyncBufferB.state == pending))
 636:Src/aspep.c   ****         {
 637:Src/aspep.c   ****           //cstat !MISRAC2012-Rule-11.4
 638:Src/aspep.c   ****           uint32_t temp = (uint32_t)&pHandle->asyncBufferA + (uint32_t)&pHandle->asyncBufferB
 639:Src/aspep.c   ****                           - (uint32_t) pHandle->asyncNextBuffer; //cstat !MISRAC2012-Rule-11.4
 640:Src/aspep.c   ****           pHandle->asyncNextBuffer = (MCTL_Buff_t *) temp; //cstat !MISRAC2012-Rule-11.4
 641:Src/aspep.c   ****         }
 642:Src/aspep.c   ****         else
 643:Src/aspep.c   ****         {
 644:Src/aspep.c   ****           pHandle->asyncNextBuffer = NULL;
 645:Src/aspep.c   ****         }
 646:Src/aspep.c   ****       }
 647:Src/aspep.c   ****       else /* No TX packet are pending, HW resource is free*/
 648:Src/aspep.c   ****       {
 649:Src/aspep.c   ****         pHandle->lockBuffer = NULL;
 650:Src/aspep.c   ****       }
 651:Src/aspep.c   ****       __enable_irq();
 652:Src/aspep.c   ****     }
 653:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 654:Src/aspep.c   ****   }
 655:Src/aspep.c   **** #endif
 656:Src/aspep.c   **** }
 1233              		.loc 1 656 1 view .LVU411
 1234 0032 38BD     		pop	{r3, r4, r5, pc}
 1235              	.LVL89:
 1236              	.L73:
 603:Src/aspep.c   ****     }
 1237              		.loc 1 603 7 is_stmt 1 view .LVU412
 610:Src/aspep.c   ****     {
 1238              		.loc 1 610 8 is_stmt 0 view .LVU413
 1239 0034 90F82E30 		ldrb	r3, [r0, #46]	@ zero_extendqisi2
 603:Src/aspep.c   ****     }
 1240              		.loc 1 603 33 view .LVU414
 1241 0038 0022     		movs	r2, #0
 610:Src/aspep.c   ****     {
 1242              		.loc 1 610 8 view .LVU415
 1243 003a 022B     		cmp	r3, #2
ARM GAS  /tmp/ccJS0l1g.s 			page 44


 603:Src/aspep.c   ****     }
 1244              		.loc 1 603 33 view .LVU416
 1245 003c 80F82420 		strb	r2, [r0, #36]
 610:Src/aspep.c   ****     {
 1246              		.loc 1 610 5 is_stmt 1 view .LVU417
 610:Src/aspep.c   ****     {
 1247              		.loc 1 610 8 is_stmt 0 view .LVU418
 1248 0040 0BD1     		bne	.L59
 1249              	.L61:
 612:Src/aspep.c   ****       pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->syncBuffer.buffer, pHandle->syncBuffer.l
 1250              		.loc 1 612 7 is_stmt 1 view .LVU419
 612:Src/aspep.c   ****       pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->syncBuffer.buffer, pHandle->syncBuffer.l
 1251              		.loc 1 612 37 is_stmt 0 view .LVU420
 1252 0042 04F12803 		add	r3, r4, #40
 612:Src/aspep.c   ****       pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, pHandle->syncBuffer.buffer, pHandle->syncBuffer.l
 1253              		.loc 1 612 27 view .LVU421
 1254 0046 A364     		str	r3, [r4, #72]
 613:Src/aspep.c   ****       pHandle->syncBuffer.state = readLock;
 1255              		.loc 1 613 7 is_stmt 1 view .LVU422
 1256 0048 A28D     		ldrh	r2, [r4, #44]
 1257 004a A36D     		ldr	r3, [r4, #88]
 1258 004c A16A     		ldr	r1, [r4, #40]
 1259 004e 6069     		ldr	r0, [r4, #20]
 1260              	.LVL90:
 613:Src/aspep.c   ****       pHandle->syncBuffer.state = readLock;
 1261              		.loc 1 613 7 is_stmt 0 view .LVU423
 1262 0050 9847     		blx	r3
 1263              	.LVL91:
 614:Src/aspep.c   ****     }
 1264              		.loc 1 614 7 is_stmt 1 view .LVU424
 614:Src/aspep.c   ****     }
 1265              		.loc 1 614 33 is_stmt 0 view .LVU425
 1266 0052 0323     		movs	r3, #3
 1267 0054 84F82E30 		strb	r3, [r4, #46]
 1268              		.loc 1 656 1 view .LVU426
 1269 0058 38BD     		pop	{r3, r4, r5, pc}
 1270              	.LVL92:
 1271              	.L59:
 625:Src/aspep.c   ****       if (pHandle->asyncNextBuffer != NULL)
 1272              		.loc 1 625 7 is_stmt 1 view .LVU427
 1273              	.LBB143:
 1274              	.LBI143:
 207:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 1275              		.loc 2 207 27 view .LVU428
 1276              	.LBB144:
 1277              		.loc 2 209 3 view .LVU429
 1278              		.syntax unified
 1279              	@ 209 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1280 005a 72B6     		cpsid i
 1281              	@ 0 "" 2
 1282              		.thumb
 1283              		.syntax unified
 1284              	.LBE144:
 1285              	.LBE143:
 626:Src/aspep.c   ****       {
 1286              		.loc 1 626 7 view .LVU430
 626:Src/aspep.c   ****       {
ARM GAS  /tmp/ccJS0l1g.s 			page 45


 1287              		.loc 1 626 18 is_stmt 0 view .LVU431
 1288 005c 636C     		ldr	r3, [r4, #68]
 626:Src/aspep.c   ****       {
 1289              		.loc 1 626 10 view .LVU432
 1290 005e CBB1     		cbz	r3, .L62
 628:Src/aspep.c   ****         pHandle->asyncNextBuffer->state = readLock;
 1291              		.loc 1 628 9 is_stmt 1 view .LVU433
 629:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 1292              		.loc 1 629 41 is_stmt 0 view .LVU434
 1293 0060 0322     		movs	r2, #3
 628:Src/aspep.c   ****         pHandle->asyncNextBuffer->state = readLock;
 1294              		.loc 1 628 29 view .LVU435
 1295 0062 A364     		str	r3, [r4, #72]
 629:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 1296              		.loc 1 629 9 is_stmt 1 view .LVU436
 633:Src/aspep.c   ****         /* If one Async buffer is still pending, assign it to the asyncNextBuffer pointer*/
 1297              		.loc 1 633 9 is_stmt 0 view .LVU437
 1298 0064 A56D     		ldr	r5, [r4, #88]
 1299 0066 1968     		ldr	r1, [r3]
 629:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 1300              		.loc 1 629 41 view .LVU438
 1301 0068 9A71     		strb	r2, [r3, #6]
 633:Src/aspep.c   ****         /* If one Async buffer is still pending, assign it to the asyncNextBuffer pointer*/
 1302              		.loc 1 633 9 is_stmt 1 view .LVU439
 1303 006a 6069     		ldr	r0, [r4, #20]
 1304              	.LVL93:
 633:Src/aspep.c   ****         /* If one Async buffer is still pending, assign it to the asyncNextBuffer pointer*/
 1305              		.loc 1 633 9 is_stmt 0 view .LVU440
 1306 006c 9A88     		ldrh	r2, [r3, #4]
 1307 006e A847     		blx	r5
 1308              	.LVL94:
 635:Src/aspep.c   ****         {
 1309              		.loc 1 635 9 is_stmt 1 view .LVU441
 635:Src/aspep.c   ****         {
 1310              		.loc 1 635 12 is_stmt 0 view .LVU442
 1311 0070 94F83630 		ldrb	r3, [r4, #54]	@ zero_extendqisi2
 1312 0074 022B     		cmp	r3, #2
 1313 0076 07D0     		beq	.L63
 635:Src/aspep.c   ****         {
 1314              		.loc 1 635 54 discriminator 1 view .LVU443
 1315 0078 94F83E30 		ldrb	r3, [r4, #62]	@ zero_extendqisi2
 1316 007c 022B     		cmp	r3, #2
 1317 007e 03D0     		beq	.L63
 644:Src/aspep.c   ****         }
 1318              		.loc 1 644 11 is_stmt 1 view .LVU444
 644:Src/aspep.c   ****         }
 1319              		.loc 1 644 36 is_stmt 0 view .LVU445
 1320 0080 0023     		movs	r3, #0
 1321 0082 6364     		str	r3, [r4, #68]
 1322              	.L65:
 651:Src/aspep.c   ****     }
 1323              		.loc 1 651 7 is_stmt 1 view .LVU446
 1324              	.LBB145:
 1325              	.LBI145:
 196:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 1326              		.loc 2 196 27 view .LVU447
 1327              	.LBB146:
ARM GAS  /tmp/ccJS0l1g.s 			page 46


 198:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 1328              		.loc 2 198 3 view .LVU448
 1329              		.syntax unified
 1330              	@ 198 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1331 0084 62B6     		cpsie i
 1332              	@ 0 "" 2
 1333              		.thumb
 1334              		.syntax unified
 1335              	.LBE146:
 1336              	.LBE145:
 1337              		.loc 1 656 1 is_stmt 0 view .LVU449
 1338 0086 38BD     		pop	{r3, r4, r5, pc}
 1339              	.LVL95:
 1340              	.L63:
 1341              	.LBB147:
 638:Src/aspep.c   ****                           - (uint32_t) pHandle->asyncNextBuffer; //cstat !MISRAC2012-Rule-11.4
 1342              		.loc 1 638 11 is_stmt 1 view .LVU450
 640:Src/aspep.c   ****         }
 1343              		.loc 1 640 11 view .LVU451
 638:Src/aspep.c   ****                           - (uint32_t) pHandle->asyncNextBuffer; //cstat !MISRAC2012-Rule-11.4
 1344              		.loc 1 638 20 is_stmt 0 view .LVU452
 1345 0088 626C     		ldr	r2, [r4, #68]
 638:Src/aspep.c   ****                           - (uint32_t) pHandle->asyncNextBuffer; //cstat !MISRAC2012-Rule-11.4
 1346              		.loc 1 638 72 view .LVU453
 1347 008a 6300     		lsls	r3, r4, #1
 638:Src/aspep.c   ****                           - (uint32_t) pHandle->asyncNextBuffer; //cstat !MISRAC2012-Rule-11.4
 1348              		.loc 1 638 60 view .LVU454
 1349 008c 6833     		adds	r3, r3, #104
 638:Src/aspep.c   ****                           - (uint32_t) pHandle->asyncNextBuffer; //cstat !MISRAC2012-Rule-11.4
 1350              		.loc 1 638 20 view .LVU455
 1351 008e 9B1A     		subs	r3, r3, r2
 640:Src/aspep.c   ****         }
 1352              		.loc 1 640 36 view .LVU456
 1353 0090 6364     		str	r3, [r4, #68]
 1354              	.LVL96:
 640:Src/aspep.c   ****         }
 1355              		.loc 1 640 36 view .LVU457
 1356              	.LBE147:
 636:Src/aspep.c   ****           //cstat !MISRAC2012-Rule-11.4
 1357              		.loc 1 636 9 view .LVU458
 1358 0092 F7E7     		b	.L65
 1359              	.LVL97:
 1360              	.L62:
 649:Src/aspep.c   ****       }
 1361              		.loc 1 649 9 is_stmt 1 view .LVU459
 649:Src/aspep.c   ****       }
 1362              		.loc 1 649 29 is_stmt 0 view .LVU460
 1363 0094 A364     		str	r3, [r4, #72]
 1364 0096 F5E7     		b	.L65
 1365              		.cfi_endproc
 1366              	.LFE1447:
 1368              		.section	.text.ASPEP_RXframeProcess,"ax",%progbits
 1369              		.align	1
 1370              		.p2align 2,,3
 1371              		.global	ASPEP_RXframeProcess
 1372              		.syntax unified
 1373              		.thumb
ARM GAS  /tmp/ccJS0l1g.s 			page 47


 1374              		.thumb_func
 1375              		.fpu fpv4-sp-d16
 1377              	ASPEP_RXframeProcess:
 1378              	.LVL98:
 1379              	.LFB1448:
 657:Src/aspep.c   **** 
 658:Src/aspep.c   **** /**
 659:Src/aspep.c   ****   * @brief  Updates ASPEP state depending on received packet from Controller and sends a response a
 660:Src/aspep.c   ****   *
 661:Src/aspep.c   ****   * ASPEP protocol defined in section 4.4.1 Connection Procedure of Motor Control Protocol Suite of
 662:Src/aspep.c   ****   *
 663:Src/aspep.c   ****   * @param  *pSupHandle Handler of the current instance of the MCTL component
 664:Src/aspep.c   ****   * @param  *packetLength Length of the packet to be processed
 665:Src/aspep.c   ****   *
 666:Src/aspep.c   ****   * @return Returns the buffer of data transmitted by the MCP controller device
 667:Src/aspep.c   ****   */
 668:Src/aspep.c   **** uint8_t *ASPEP_RXframeProcess(MCTL_Handle_t *pSupHandle, uint16_t *packetLength)
 669:Src/aspep.c   **** {
 1380              		.loc 1 669 1 is_stmt 1 view -0
 1381              		.cfi_startproc
 1382              		@ args = 0, pretend = 0, frame = 0
 1383              		@ frame_needed = 0, uses_anonymous_args = 0
 670:Src/aspep.c   ****   uint8_t *result = NULL; //cstat !MISRAC2012-Rule-8.13
 1384              		.loc 1 670 3 view .LVU462
 671:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 672:Src/aspep.c   ****   if ((NULL == pSupHandle) || (NULL == packetLength))
 673:Src/aspep.c   ****   {
 674:Src/aspep.c   ****     /* Nothing to do */
 675:Src/aspep.c   ****   }
 676:Src/aspep.c   ****   else
 677:Src/aspep.c   ****   {
 678:Src/aspep.c   **** #endif
 679:Src/aspep.c   ****     ASPEP_Handle_t *pHandle = (ASPEP_Handle_t *)pSupHandle; //cstat !MISRAC2012-Rule-11.3
 1385              		.loc 1 679 5 view .LVU463
 680:Src/aspep.c   ****     uint32_t packetHeader = *((uint32_t *)pHandle->rxHeader); //cstat !MISRAC2012-Rule-11.3
 681:Src/aspep.c   ****     uint16_t packetNumber;
 682:Src/aspep.c   **** #if VALID_CRC_DATA
 683:Src/aspep.c   ****     bool validCRCData = true;
 684:Src/aspep.c   **** #endif
 685:Src/aspep.c   ****     *packetLength = 0;
 686:Src/aspep.c   ****     if (pHandle->NewPacketAvailable)
 1386              		.loc 1 686 8 is_stmt 0 view .LVU464
 1387 0000 90F86130 		ldrb	r3, [r0, #97]	@ zero_extendqisi2
 680:Src/aspep.c   ****     uint32_t packetHeader = *((uint32_t *)pHandle->rxHeader); //cstat !MISRAC2012-Rule-11.3
 1388              		.loc 1 680 14 view .LVU465
 1389 0004 C269     		ldr	r2, [r0, #28]
 669:Src/aspep.c   ****   uint8_t *result = NULL; //cstat !MISRAC2012-Rule-8.13
 1390              		.loc 1 669 1 view .LVU466
 1391 0006 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 1392              	.LCFI20:
 1393              		.cfi_def_cfa_offset 32
 1394              		.cfi_offset 4, -32
 1395              		.cfi_offset 5, -28
 1396              		.cfi_offset 6, -24
 1397              		.cfi_offset 7, -20
 1398              		.cfi_offset 8, -16
 1399              		.cfi_offset 9, -12
ARM GAS  /tmp/ccJS0l1g.s 			page 48


 1400              		.cfi_offset 10, -8
 1401              		.cfi_offset 14, -4
 685:Src/aspep.c   ****     if (pHandle->NewPacketAvailable)
 1402              		.loc 1 685 19 view .LVU467
 1403 000a 0025     		movs	r5, #0
 669:Src/aspep.c   ****   uint8_t *result = NULL; //cstat !MISRAC2012-Rule-8.13
 1404              		.loc 1 669 1 view .LVU468
 1405 000c 0446     		mov	r4, r0
 1406              	.LVL99:
 680:Src/aspep.c   ****     uint32_t packetHeader = *((uint32_t *)pHandle->rxHeader); //cstat !MISRAC2012-Rule-11.3
 1407              		.loc 1 680 5 is_stmt 1 view .LVU469
 681:Src/aspep.c   **** #if VALID_CRC_DATA
 1408              		.loc 1 681 5 view .LVU470
 685:Src/aspep.c   ****     if (pHandle->NewPacketAvailable)
 1409              		.loc 1 685 5 view .LVU471
 685:Src/aspep.c   ****     if (pHandle->NewPacketAvailable)
 1410              		.loc 1 685 19 is_stmt 0 view .LVU472
 1411 000e 0D80     		strh	r5, [r1]	@ movhi
 1412              		.loc 1 686 5 is_stmt 1 view .LVU473
 1413              		.loc 1 686 8 is_stmt 0 view .LVU474
 1414 0010 DBB1     		cbz	r3, .L75
 687:Src/aspep.c   ****     {
 688:Src/aspep.c   ****       pHandle->NewPacketAvailable = false; /* Consumes new packet*/
 1415              		.loc 1 688 7 is_stmt 1 view .LVU475
 689:Src/aspep.c   ****       switch (pHandle->ASPEP_State)
 1416              		.loc 1 689 22 is_stmt 0 view .LVU476
 1417 0012 90F86430 		ldrb	r3, [r0, #100]	@ zero_extendqisi2
 688:Src/aspep.c   ****       switch (pHandle->ASPEP_State)
 1418              		.loc 1 688 35 view .LVU477
 1419 0016 80F86150 		strb	r5, [r0, #97]
 1420              		.loc 1 689 7 is_stmt 1 view .LVU478
 1421 001a 012B     		cmp	r3, #1
 1422 001c 1BD0     		beq	.L76
 1423 001e 5EB2     		sxtb	r6, r3
 1424 0020 002E     		cmp	r6, #0
 1425 0022 4ED0     		beq	.L77
 1426 0024 022B     		cmp	r3, #2
 1427 0026 07D1     		bne	.L79
 690:Src/aspep.c   ****       {
 691:Src/aspep.c   ****         case ASPEP_IDLE:
 692:Src/aspep.c   ****         {
 693:Src/aspep.c   ****           if (BEACON == pHandle->rxPacketType)
 694:Src/aspep.c   ****           {
 695:Src/aspep.c   ****             if (ASPEP_CheckBeacon(pHandle) == true)
 696:Src/aspep.c   ****             {
 697:Src/aspep.c   ****               /* Controller capabilities match performer capabilities.*/
 698:Src/aspep.c   ****               pSupHandle->txSyncMaxPayload = (pHandle->Capabilities.TXS_maxSize + (uint16_t)1U) * (
 699:Src/aspep.c   ****               pSupHandle->txAsyncMaxPayload = (pHandle->Capabilities.TXA_maxSize) * (uint16_t)64U;
 700:Src/aspep.c   ****               pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t
 701:Src/aspep.c   ****               pHandle->ASPEP_State = ASPEP_CONFIGURED;
 702:Src/aspep.c   ****             }
 703:Src/aspep.c   ****             else
 704:Src/aspep.c   ****             {
 705:Src/aspep.c   ****               /* Nothing to do, controller has to send back new beacon with matching capabilities *
 706:Src/aspep.c   ****             }
 707:Src/aspep.c   ****             /* Beacon Packet must be answered*/
 708:Src/aspep.c   ****             ASPEP_sendBeacon(pHandle, &pHandle->Capabilities);
ARM GAS  /tmp/ccJS0l1g.s 			page 49


 709:Src/aspep.c   ****           }
 710:Src/aspep.c   ****           else if (PING == pHandle->rxPacketType)
 711:Src/aspep.c   ****           {
 712:Src/aspep.c   ****             /* In Listening for controller performer, */
 713:Src/aspep.c   ****             packetNumber = (uint16_t)((packetHeader & 0x0FFFF000U) >> (uint16_t)12U);
 714:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_RESET, packetNumber);
 715:Src/aspep.c   ****           }
 716:Src/aspep.c   ****           else
 717:Src/aspep.c   ****           {
 718:Src/aspep.c   ****             /* Nothing to do */
 719:Src/aspep.c   ****           }
 720:Src/aspep.c   ****           break;
 721:Src/aspep.c   ****         }
 722:Src/aspep.c   **** 
 723:Src/aspep.c   ****         case ASPEP_CONFIGURED:
 724:Src/aspep.c   ****         {
 725:Src/aspep.c   ****           if (BEACON == pHandle->rxPacketType)
 726:Src/aspep.c   ****           {
 727:Src/aspep.c   ****             if (ASPEP_CheckBeacon(pHandle) == false)
 728:Src/aspep.c   ****             {
 729:Src/aspep.c   ****               pHandle->ASPEP_State = ASPEP_IDLE;
 730:Src/aspep.c   ****             }
 731:Src/aspep.c   ****             else
 732:Src/aspep.c   ****             {
 733:Src/aspep.c   ****               /* Nothing to do */
 734:Src/aspep.c   ****             }
 735:Src/aspep.c   **** 
 736:Src/aspep.c   ****             ASPEP_sendBeacon (pHandle, &pHandle->Capabilities);
 737:Src/aspep.c   ****           }
 738:Src/aspep.c   ****           else if (PING == pHandle->rxPacketType)
 739:Src/aspep.c   ****           {
 740:Src/aspep.c   ****             /* In Listening for controller performer, */
 741:Src/aspep.c   ****             packetNumber = (uint16_t)((packetHeader & 0x0FFFF000U) >> (uint16_t)12U);
 742:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 743:Src/aspep.c   ****             pHandle->ASPEP_State = ASPEP_CONNECTED;
 744:Src/aspep.c   ****           }
 745:Src/aspep.c   ****           else
 746:Src/aspep.c   ****           {
 747:Src/aspep.c   ****             /* Nothing to do */
 748:Src/aspep.c   ****           }
 749:Src/aspep.c   ****           break;
 750:Src/aspep.c   ****         }
 751:Src/aspep.c   **** 
 752:Src/aspep.c   ****         case ASPEP_CONNECTED:
 753:Src/aspep.c   ****         {
 754:Src/aspep.c   ****           if (BEACON == pHandle->rxPacketType)
 1428              		.loc 1 754 11 view .LVU479
 1429              		.loc 1 754 32 is_stmt 0 view .LVU480
 1430 0028 836E     		ldr	r3, [r0, #104]
 1431              		.loc 1 754 14 view .LVU481
 1432 002a 052B     		cmp	r3, #5
 1433 002c 5DD0     		beq	.L102
 755:Src/aspep.c   ****           {
 756:Src/aspep.c   ****             if (ASPEP_CheckBeacon(pHandle) == false)
 757:Src/aspep.c   ****             {
 758:Src/aspep.c   ****               pHandle->ASPEP_State = ASPEP_IDLE;
 759:Src/aspep.c   ****             }
ARM GAS  /tmp/ccJS0l1g.s 			page 50


 760:Src/aspep.c   ****             else
 761:Src/aspep.c   ****             {
 762:Src/aspep.c   ****               pHandle->ASPEP_State = ASPEP_CONFIGURED;
 763:Src/aspep.c   ****             }
 764:Src/aspep.c   ****             ASPEP_sendBeacon(pHandle, &pHandle->Capabilities);
 765:Src/aspep.c   ****           }
 766:Src/aspep.c   ****           else if (PING == pHandle->rxPacketType)
 1434              		.loc 1 766 16 is_stmt 1 view .LVU482
 1435              		.loc 1 766 19 is_stmt 0 view .LVU483
 1436 002e 062B     		cmp	r3, #6
 1437 0030 00F00C81 		beq	.L103
 767:Src/aspep.c   ****           {
 768:Src/aspep.c   ****             packetNumber = (uint16_t)((packetHeader & 0x0FFFF000U) >> (uint16_t)12U);
 769:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 770:Src/aspep.c   ****           }
 771:Src/aspep.c   ****           else if (DATA_PACKET == pHandle->rxPacketType)
 1438              		.loc 1 771 16 is_stmt 1 view .LVU484
 1439              		.loc 1 771 19 is_stmt 0 view .LVU485
 1440 0034 092B     		cmp	r3, #9
 1441 0036 4CD0     		beq	.L104
 1442              	.LVL100:
 1443              	.L79:
 772:Src/aspep.c   ****           {
 773:Src/aspep.c   **** #if VALID_CRC_DATA
 774:Src/aspep.c   ****             if (validCRCData)
 775:Src/aspep.c   ****             {
 776:Src/aspep.c   **** #endif
 777:Src/aspep.c   ****               pHandle->syncPacketCount++; /* this counter is incremented at each valid data packet 
 778:Src/aspep.c   ****               pSupHandle->MCP_PacketAvailable = true; /* Will be consumed in ASPEP_sendPacket */
 779:Src/aspep.c   ****               *packetLength = pHandle->rxLengthASPEP;
 780:Src/aspep.c   ****               result = pHandle->rxBuffer;
 781:Src/aspep.c   **** #if VALID_CRC_DATA
 782:Src/aspep.c   ****             }
 783:Src/aspep.c   ****             else
 784:Src/aspep.c   ****             {
 785:Src/aspep.c   ****               ASPEP_sendNack (pHandle, ASPEP_BAD_CRC_DATA);
 786:Src/aspep.c   ****             }
 787:Src/aspep.c   **** #endif
 788:Src/aspep.c   ****           }
 789:Src/aspep.c   ****           else
 790:Src/aspep.c   ****           {
 791:Src/aspep.c   ****             /* This condition is not reachable because already filtred by NewPacketAvailable */
 792:Src/aspep.c   ****             /* ASPEP_sendNack (pHandle, ASPEP_BAD_PACKET_TYPE) */
 793:Src/aspep.c   ****           }
 794:Src/aspep.c   ****           break;
 795:Src/aspep.c   ****         }
 796:Src/aspep.c   **** 
 797:Src/aspep.c   ****         default:
 798:Src/aspep.c   ****           break;
 799:Src/aspep.c   ****       }
 800:Src/aspep.c   ****       /* The valid received packet is now safely consumes, we are ready to receive a new packet */
 801:Src/aspep.c   ****       pHandle->fASPEP_cfg_recept(pHandle->ASPEPIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 1444              		.loc 1 801 7 is_stmt 1 view .LVU486
 1445 0038 6069     		ldr	r0, [r4, #20]
 1446 003a 636D     		ldr	r3, [r4, #84]
 1447 003c 0422     		movs	r2, #4
 1448 003e 04F11C01 		add	r1, r4, #28
ARM GAS  /tmp/ccJS0l1g.s 			page 51


 1449 0042 9847     		blx	r3
 1450              	.LVL101:
 802:Src/aspep.c   ****     }
 803:Src/aspep.c   ****     else if (pHandle->badPacketFlag > ASPEP_OK)
 804:Src/aspep.c   ****     {
 805:Src/aspep.c   ****       ASPEP_sendNack(pHandle, pHandle->badPacketFlag);
 806:Src/aspep.c   ****       /* ASPEP_RXframeProcess can be called before reception of another packet */
 807:Src/aspep.c   ****       pHandle->badPacketFlag = ASPEP_OK;
 808:Src/aspep.c   ****       /* As we received a packet with a bad header, we need to be sure that the HW IP is well Synch
 809:Src/aspep.c   ****         * DMA will be configured to receive next packet as soon as HW IP RX line is free to receive
 810:Src/aspep.c   ****         * It is important to note that we will detect only the NEXT free line transition, it means 
 811:Src/aspep.c   ****         * be lost but the end of this lost packet will generate the IDLE interrupt
 812:Src/aspep.c   ****         * the IDLE interrupt will call ASPEP_HWReset (in charge of the IP_aspep driver to call it a
 813:Src/aspep.c   ****         * time)*/
 814:Src/aspep.c   ****       pHandle->fASPEP_HWSync(pHandle->ASPEPIp);
 815:Src/aspep.c   ****     }
 816:Src/aspep.c   ****     else
 817:Src/aspep.c   ****     {
 818:Src/aspep.c   ****       /* Nothing to do, no response is due to the controller */
 819:Src/aspep.c   ****     }
 820:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 821:Src/aspep.c   ****   }
 822:Src/aspep.c   **** #endif
 823:Src/aspep.c   ****   return (result);
 824:Src/aspep.c   **** }
 1451              		.loc 1 824 1 is_stmt 0 view .LVU487
 1452 0044 2846     		mov	r0, r5
 1453 0046 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 1454              	.LVL102:
 1455              	.L75:
 803:Src/aspep.c   ****     {
 1456              		.loc 1 803 10 is_stmt 1 view .LVU488
 803:Src/aspep.c   ****     {
 1457              		.loc 1 803 21 is_stmt 0 view .LVU489
 1458 004a 90F86250 		ldrb	r5, [r0, #98]	@ zero_extendqisi2
 803:Src/aspep.c   ****     {
 1459              		.loc 1 803 13 view .LVU490
 1460 004e 8DB9     		cbnz	r5, .L105
 1461              		.loc 1 824 1 view .LVU491
 1462 0050 2846     		mov	r0, r5
 1463              	.LVL103:
 1464              		.loc 1 824 1 view .LVU492
 1465 0052 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 1466              	.LVL104:
 1467              	.L76:
 725:Src/aspep.c   ****           {
 1468              		.loc 1 725 11 is_stmt 1 view .LVU493
 725:Src/aspep.c   ****           {
 1469              		.loc 1 725 32 is_stmt 0 view .LVU494
 1470 0056 816E     		ldr	r1, [r0, #104]
 1471              	.LVL105:
 725:Src/aspep.c   ****           {
 1472              		.loc 1 725 14 view .LVU495
 1473 0058 0529     		cmp	r1, #5
 1474 005a 00F08680 		beq	.L106
 738:Src/aspep.c   ****           {
 1475              		.loc 1 738 16 is_stmt 1 view .LVU496
ARM GAS  /tmp/ccJS0l1g.s 			page 52


 738:Src/aspep.c   ****           {
 1476              		.loc 1 738 19 is_stmt 0 view .LVU497
 1477 005e 0629     		cmp	r1, #6
 1478 0060 EAD1     		bne	.L79
 741:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 1479              		.loc 1 741 13 is_stmt 1 view .LVU498
 1480              	.LVL106:
 742:Src/aspep.c   ****             pHandle->ASPEP_State = ASPEP_CONNECTED;
 1481              		.loc 1 742 13 view .LVU499
 1482 0062 1946     		mov	r1, r3
 1483 0064 C2F30F32 		ubfx	r2, r2, #12, #16
 1484              	.LVL107:
 742:Src/aspep.c   ****             pHandle->ASPEP_State = ASPEP_CONNECTED;
 1485              		.loc 1 742 13 is_stmt 0 view .LVU500
 1486 0068 FFF7FEFF 		bl	ASPEP_sendPing
 1487              	.LVL108:
 743:Src/aspep.c   ****           }
 1488              		.loc 1 743 13 is_stmt 1 view .LVU501
 743:Src/aspep.c   ****           }
 1489              		.loc 1 743 34 is_stmt 0 view .LVU502
 1490 006c 0223     		movs	r3, #2
 1491 006e 84F86430 		strb	r3, [r4, #100]
 1492 0072 E1E7     		b	.L79
 1493              	.LVL109:
 1494              	.L105:
 805:Src/aspep.c   ****       /* ASPEP_RXframeProcess can be called before reception of another packet */
 1495              		.loc 1 805 7 is_stmt 1 view .LVU503
 1496              	.LBB166:
 1497              	.LBI166:
 237:Src/aspep.c   **** {
 1498              		.loc 1 237 13 view .LVU504
 1499              	.LBB167:
 239:Src/aspep.c   ****   *packet = NACK | (uint32_t)(((uint32_t) errorInfo) << 8U) | (uint32_t)(((uint32_t) errorInfo) << 
 1500              		.loc 1 239 3 view .LVU505
 240:Src/aspep.c   ****   (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 1501              		.loc 1 240 3 view .LVU506
 240:Src/aspep.c   ****   (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 1502              		.loc 1 240 63 is_stmt 0 view .LVU507
 1503 0074 2B04     		lsls	r3, r5, #16
 240:Src/aspep.c   ****   (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 1504              		.loc 1 240 61 view .LVU508
 1505 0076 43EA0525 		orr	r5, r3, r5, lsl #8
 1506              	.LVL110:
 240:Src/aspep.c   ****   (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 1507              		.loc 1 240 61 view .LVU509
 1508 007a 45F00F05 		orr	r5, r5, #15
 241:Src/aspep.c   **** }
 1509              		.loc 1 241 3 is_stmt 1 view .LVU510
 1510              	.LVL111:
 1511              	.LBB168:
 1512              	.LBI168:
 479:Src/aspep.c   **** {
 1513              		.loc 1 479 9 view .LVU511
 1514              	.LBB169:
 481:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 1515              		.loc 1 481 3 view .LVU512
 491:Src/aspep.c   ****     __disable_irq(); /*TODO: Disable High frequency task is enough */
ARM GAS  /tmp/ccJS0l1g.s 			page 53


 1516              		.loc 1 491 5 view .LVU513
 1517              	.LBB170:
 1518              	.LBI170:
 118:Src/aspep.c   **** {
 1519              		.loc 1 118 13 view .LVU514
 1520              	.LBB171:
 120:Src/aspep.c   ****   uint32_t header = *headerPtr;
 1521              		.loc 1 120 3 view .LVU515
 121:Src/aspep.c   **** 
 1522              		.loc 1 121 3 view .LVU516
 124:Src/aspep.c   **** 
 1523              		.loc 1 124 3 view .LVU517
 126:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 1524              		.loc 1 126 3 view .LVU518
 127:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 1525              		.loc 1 127 3 view .LVU519
 128:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 1526              		.loc 1 128 3 view .LVU520
 127:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 1527              		.loc 1 127 26 is_stmt 0 view .LVU521
 1528 007e C5F30723 		ubfx	r3, r5, #8, #8
 127:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 1529              		.loc 1 127 7 view .LVU522
 1530 0082 884A     		ldr	r2, .L112
 1531              	.LVL112:
 129:Src/aspep.c   **** #else /* CRC4_PER_NIBBLE */
 1532              		.loc 1 129 7 view .LVU523
 1533 0084 8849     		ldr	r1, .L112+4
 1534              	.LVL113:
 127:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 1535              		.loc 1 127 26 view .LVU524
 1536 0086 83F00903 		eor	r3, r3, #9
 128:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 1537              		.loc 1 128 26 view .LVU525
 1538 008a D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 1539 008c 83EA1543 		eor	r3, r3, r5, lsr #16
 1540              	.LVL114:
 129:Src/aspep.c   **** #else /* CRC4_PER_NIBBLE */
 1541              		.loc 1 129 3 is_stmt 1 view .LVU526
 129:Src/aspep.c   **** #else /* CRC4_PER_NIBBLE */
 1542              		.loc 1 129 26 is_stmt 0 view .LVU527
 1543 0090 D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 1544              	.LVL115:
 140:Src/aspep.c   **** 
 1545              		.loc 1 140 3 is_stmt 1 view .LVU528
 140:Src/aspep.c   **** 
 1546              		.loc 1 140 17 is_stmt 0 view .LVU529
 1547 0092 CB5C     		ldrb	r3, [r1, r3]	@ zero_extendqisi2
 1548              	.LVL116:
 140:Src/aspep.c   **** 
 1549              		.loc 1 140 14 view .LVU530
 1550 0094 45EA0375 		orr	r5, r5, r3, lsl #28
 1551              	.LVL117:
 140:Src/aspep.c   **** 
 1552              		.loc 1 140 14 view .LVU531
 1553 0098 0562     		str	r5, [r0, #32]
 1554              	.LVL118:
ARM GAS  /tmp/ccJS0l1g.s 			page 54


 140:Src/aspep.c   **** 
 1555              		.loc 1 140 14 view .LVU532
 1556              	.LBE171:
 1557              	.LBE170:
 492:Src/aspep.c   ****     if (NULL == pHandle->lockBuffer) /* Communication Ip free to send data*/
 1558              		.loc 1 492 5 is_stmt 1 view .LVU533
 1559              	.LBB172:
 1560              	.LBI172:
 207:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 1561              		.loc 2 207 27 view .LVU534
 1562              	.LBB173:
 1563              		.loc 2 209 3 view .LVU535
 1564              		.syntax unified
 1565              	@ 209 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1566 009a 72B6     		cpsid i
 1567              	@ 0 "" 2
 1568              		.thumb
 1569              		.syntax unified
 1570              	.LBE173:
 1571              	.LBE172:
 493:Src/aspep.c   ****     {
 1572              		.loc 1 493 5 view .LVU536
 493:Src/aspep.c   ****     {
 1573              		.loc 1 493 8 is_stmt 0 view .LVU537
 1574 009c 836C     		ldr	r3, [r0, #72]
 1575 009e 002B     		cmp	r3, #0
 1576 00a0 57D0     		beq	.L107
 520:Src/aspep.c   ****       /* Lock buffer can be freed here */
 1577              		.loc 1 520 7 is_stmt 1 view .LVU538
 1578              	.LBB174:
 1579              	.LBI174:
 196:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 1580              		.loc 2 196 27 view .LVU539
 1581              	.LBB175:
 198:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 1582              		.loc 2 198 3 view .LVU540
 1583              		.syntax unified
 1584              	@ 198 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1585 00a2 62B6     		cpsie i
 1586              	@ 0 "" 2
 1587              		.thumb
 1588              		.syntax unified
 1589              	.LBE175:
 1590              	.LBE174:
 522:Src/aspep.c   ****       {
 1591              		.loc 1 522 7 view .LVU541
 548:Src/aspep.c   ****       {
 1592              		.loc 1 548 12 view .LVU542
 560:Src/aspep.c   ****       {
 1593              		.loc 1 560 12 view .LVU543
 562:Src/aspep.c   ****         {
 1594              		.loc 1 562 9 view .LVU544
 562:Src/aspep.c   ****         {
 1595              		.loc 1 562 12 is_stmt 0 view .LVU545
 1596 00a4 90F82430 		ldrb	r3, [r0, #36]	@ zero_extendqisi2
 1597 00a8 13B9     		cbnz	r3, .L91
 568:Src/aspep.c   ****         }
ARM GAS  /tmp/ccJS0l1g.s 			page 55


 1598              		.loc 1 568 11 is_stmt 1 view .LVU546
 568:Src/aspep.c   ****         }
 1599              		.loc 1 568 37 is_stmt 0 view .LVU547
 1600 00aa 0223     		movs	r3, #2
 1601 00ac 80F82430 		strb	r3, [r0, #36]
 1602              	.LVL119:
 1603              	.L91:
 574:Src/aspep.c   ****     }
 1604              		.loc 1 574 7 is_stmt 1 view .LVU548
 579:Src/aspep.c   **** }
 1605              		.loc 1 579 3 view .LVU549
 579:Src/aspep.c   **** }
 1606              		.loc 1 579 3 is_stmt 0 view .LVU550
 1607              	.LBE169:
 1608              	.LBE168:
 1609              	.LBE167:
 1610              	.LBE166:
 807:Src/aspep.c   ****       /* As we received a packet with a bad header, we need to be sure that the HW IP is well Synch
 1611              		.loc 1 807 7 is_stmt 1 view .LVU551
 807:Src/aspep.c   ****       /* As we received a packet with a bad header, we need to be sure that the HW IP is well Synch
 1612              		.loc 1 807 30 is_stmt 0 view .LVU552
 1613 00b0 0025     		movs	r5, #0
 814:Src/aspep.c   ****     }
 1614              		.loc 1 814 7 view .LVU553
 1615 00b2 6069     		ldr	r0, [r4, #20]
 807:Src/aspep.c   ****       /* As we received a packet with a bad header, we need to be sure that the HW IP is well Synch
 1616              		.loc 1 807 30 view .LVU554
 1617 00b4 84F86250 		strb	r5, [r4, #98]
 814:Src/aspep.c   ****     }
 1618              		.loc 1 814 7 is_stmt 1 view .LVU555
 1619 00b8 236D     		ldr	r3, [r4, #80]
 1620 00ba 9847     		blx	r3
 1621              	.LVL120:
 1622              		.loc 1 824 1 is_stmt 0 view .LVU556
 1623 00bc 2846     		mov	r0, r5
 1624 00be BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 1625              	.LVL121:
 1626              	.L77:
 693:Src/aspep.c   ****           {
 1627              		.loc 1 693 11 is_stmt 1 view .LVU557
 693:Src/aspep.c   ****           {
 1628              		.loc 1 693 32 is_stmt 0 view .LVU558
 1629 00c2 836E     		ldr	r3, [r0, #104]
 693:Src/aspep.c   ****           {
 1630              		.loc 1 693 14 view .LVU559
 1631 00c4 052B     		cmp	r3, #5
 1632 00c6 7ED0     		beq	.L108
 710:Src/aspep.c   ****           {
 1633              		.loc 1 710 16 is_stmt 1 view .LVU560
 710:Src/aspep.c   ****           {
 1634              		.loc 1 710 19 is_stmt 0 view .LVU561
 1635 00c8 062B     		cmp	r3, #6
 1636 00ca 00F0C580 		beq	.L109
 670:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 1637              		.loc 1 670 12 view .LVU562
 1638 00ce 3546     		mov	r5, r6
 1639 00d0 B2E7     		b	.L79
ARM GAS  /tmp/ccJS0l1g.s 			page 56


 1640              	.L104:
 777:Src/aspep.c   ****               pSupHandle->MCP_PacketAvailable = true; /* Will be consumed in ASPEP_sendPacket */
 1641              		.loc 1 777 15 is_stmt 1 view .LVU563
 777:Src/aspep.c   ****               pSupHandle->MCP_PacketAvailable = true; /* Will be consumed in ASPEP_sendPacket */
 1642              		.loc 1 777 39 is_stmt 0 view .LVU564
 1643 00d2 90F86030 		ldrb	r3, [r0, #96]	@ zero_extendqisi2
 779:Src/aspep.c   ****               result = pHandle->rxBuffer;
 1644              		.loc 1 779 38 view .LVU565
 1645 00d6 B0F85C20 		ldrh	r2, [r0, #92]
 1646              	.LVL122:
 780:Src/aspep.c   **** #if VALID_CRC_DATA
 1647              		.loc 1 780 22 view .LVU566
 1648 00da 8569     		ldr	r5, [r0, #24]
 777:Src/aspep.c   ****               pSupHandle->MCP_PacketAvailable = true; /* Will be consumed in ASPEP_sendPacket */
 1649              		.loc 1 777 39 view .LVU567
 1650 00dc 0133     		adds	r3, r3, #1
 778:Src/aspep.c   ****               *packetLength = pHandle->rxLengthASPEP;
 1651              		.loc 1 778 47 view .LVU568
 1652 00de 0120     		movs	r0, #1
 1653              	.LVL123:
 777:Src/aspep.c   ****               pSupHandle->MCP_PacketAvailable = true; /* Will be consumed in ASPEP_sendPacket */
 1654              		.loc 1 777 39 view .LVU569
 1655 00e0 84F86030 		strb	r3, [r4, #96]
 778:Src/aspep.c   ****               *packetLength = pHandle->rxLengthASPEP;
 1656              		.loc 1 778 15 is_stmt 1 view .LVU570
 778:Src/aspep.c   ****               *packetLength = pHandle->rxLengthASPEP;
 1657              		.loc 1 778 47 is_stmt 0 view .LVU571
 1658 00e4 2074     		strb	r0, [r4, #16]
 779:Src/aspep.c   ****               result = pHandle->rxBuffer;
 1659              		.loc 1 779 15 is_stmt 1 view .LVU572
 779:Src/aspep.c   ****               result = pHandle->rxBuffer;
 1660              		.loc 1 779 29 is_stmt 0 view .LVU573
 1661 00e6 0A80     		strh	r2, [r1]	@ movhi
 780:Src/aspep.c   **** #if VALID_CRC_DATA
 1662              		.loc 1 780 15 is_stmt 1 view .LVU574
 1663              	.LVL124:
 780:Src/aspep.c   **** #if VALID_CRC_DATA
 1664              		.loc 1 780 15 is_stmt 0 view .LVU575
 1665 00e8 A6E7     		b	.L79
 1666              	.LVL125:
 1667              	.L102:
 756:Src/aspep.c   ****             {
 1668              		.loc 1 756 13 is_stmt 1 view .LVU576
 1669              	.LBB181:
 1670              	.LBI181:
 355:Src/aspep.c   **** {
 1671              		.loc 1 355 6 view .LVU577
 1672              	.LBB182:
 357:Src/aspep.c   **** 
 1673              		.loc 1 357 3 view .LVU578
 359:Src/aspep.c   ****   ASPEP_Capabilities_def MasterCapabilities;
 1674              		.loc 1 359 3 view .LVU579
 360:Src/aspep.c   ****   MasterCapabilities.version = (uint8_t)((packetHeader &0x70U)>> 4U);           /*Bits 4 to 6*/
 1675              		.loc 1 360 3 view .LVU580
 361:Src/aspep.c   ****   MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 1676              		.loc 1 361 3 view .LVU581
 362:Src/aspep.c   ****   MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
ARM GAS  /tmp/ccJS0l1g.s 			page 57


 1677              		.loc 1 362 3 view .LVU582
 362:Src/aspep.c   ****   MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 1678              		.loc 1 362 31 is_stmt 0 view .LVU583
 1679 00ea 037F     		ldrb	r3, [r0, #28]	@ zero_extendqisi2
 367:Src/aspep.c   ****   pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_ma
 1680              		.loc 1 367 36 view .LVU584
 1681 00ec 94F86C60 		ldrb	r6, [r4, #108]	@ zero_extendqisi2
 363:Src/aspep.c   ****   MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
 1682              		.loc 1 363 56 view .LVU585
 1683 00f0 407F     		ldrb	r0, [r0, #29]	@ zero_extendqisi2
 1684              	.LVL126:
 368:Src/aspep.c   ****   pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS
 1685              		.loc 1 368 38 view .LVU586
 1686 00f2 94F86D10 		ldrb	r1, [r4, #109]	@ zero_extendqisi2
 1687              	.LVL127:
 369:Src/aspep.c   ****   pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA
 1688              		.loc 1 369 39 view .LVU587
 1689 00f6 94F86E70 		ldrb	r7, [r4, #110]	@ zero_extendqisi2
 370:Src/aspep.c   **** 
 1690              		.loc 1 370 39 view .LVU588
 1691 00fa 94F86FE0 		ldrb	lr, [r4, #111]	@ zero_extendqisi2
 362:Src/aspep.c   ****   MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 1692              		.loc 1 362 31 view .LVU589
 1693 00fe DB09     		lsrs	r3, r3, #7
 1694              	.LVL128:
 363:Src/aspep.c   ****   MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
 1695              		.loc 1 363 3 is_stmt 1 view .LVU590
 363:Src/aspep.c   ****   MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
 1696              		.loc 1 363 56 is_stmt 0 view .LVU591
 1697 0100 00F03F00 		and	r0, r0, #63
 1698              	.LVL129:
 364:Src/aspep.c   ****   MasterCapabilities.TXA_maxSize = (uint8_t)((packetHeader&0xFE00000U) >> 21);  /*Bits 21 to 27  */
 1699              		.loc 1 364 3 is_stmt 1 view .LVU592
 367:Src/aspep.c   ****   pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_ma
 1700              		.loc 1 367 36 is_stmt 0 view .LVU593
 1701 0104 B342     		cmp	r3, r6
 1702 0106 9946     		mov	r9, r3
 364:Src/aspep.c   ****   MasterCapabilities.TXA_maxSize = (uint8_t)((packetHeader&0xFE00000U) >> 21);  /*Bits 21 to 27  */
 1703              		.loc 1 364 36 view .LVU594
 1704 0108 C2F3863C 		ubfx	ip, r2, #14, #7
 1705              	.LVL130:
 365:Src/aspep.c   **** 
 1706              		.loc 1 365 3 is_stmt 1 view .LVU595
 367:Src/aspep.c   ****   pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_ma
 1707              		.loc 1 367 36 is_stmt 0 view .LVU596
 1708 010c 28BF     		it	cs
 1709 010e B146     		movcs	r9, r6
 368:Src/aspep.c   ****   pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS
 1710              		.loc 1 368 38 view .LVU597
 1711 0110 8142     		cmp	r1, r0
 365:Src/aspep.c   **** 
 1712              		.loc 1 365 36 view .LVU598
 1713 0112 C2F34658 		ubfx	r8, r2, #21, #7
 1714              	.LVL131:
 367:Src/aspep.c   ****   pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_ma
 1715              		.loc 1 367 3 is_stmt 1 view .LVU599
 368:Src/aspep.c   ****   pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS
ARM GAS  /tmp/ccJS0l1g.s 			page 58


 1716              		.loc 1 368 38 is_stmt 0 view .LVU600
 1717 0116 28BF     		it	cs
 1718 0118 0146     		movcs	r1, r0
 369:Src/aspep.c   ****   pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA
 1719              		.loc 1 369 39 view .LVU601
 1720 011a BC45     		cmp	ip, r7
 1721 011c E246     		mov	r10, ip
 1722 011e 28BF     		it	cs
 1723 0120 BA46     		movcs	r10, r7
 370:Src/aspep.c   **** 
 1724              		.loc 1 370 39 view .LVU602
 1725 0122 F045     		cmp	r8, lr
 367:Src/aspep.c   ****   pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_ma
 1726              		.loc 1 367 34 view .LVU603
 1727 0124 84F86C90 		strb	r9, [r4, #108]
 368:Src/aspep.c   ****   pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS
 1728              		.loc 1 368 3 is_stmt 1 view .LVU604
 370:Src/aspep.c   **** 
 1729              		.loc 1 370 39 is_stmt 0 view .LVU605
 1730 0128 C146     		mov	r9, r8
 1731 012a 28BF     		it	cs
 1732 012c F146     		movcs	r9, lr
 372:Src/aspep.c   ****    /* Data packet the controller can send is bigger than performer can receive */
 1733              		.loc 1 372 6 view .LVU606
 1734 012e B342     		cmp	r3, r6
 368:Src/aspep.c   ****   pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS
 1735              		.loc 1 368 36 view .LVU607
 1736 0130 84F86D10 		strb	r1, [r4, #109]
 369:Src/aspep.c   ****   pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA
 1737              		.loc 1 369 3 is_stmt 1 view .LVU608
 369:Src/aspep.c   ****   pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA
 1738              		.loc 1 369 37 is_stmt 0 view .LVU609
 1739 0134 84F86EA0 		strb	r10, [r4, #110]
 370:Src/aspep.c   **** 
 1740              		.loc 1 370 3 is_stmt 1 view .LVU610
 370:Src/aspep.c   **** 
 1741              		.loc 1 370 37 is_stmt 0 view .LVU611
 1742 0138 84F86F90 		strb	r9, [r4, #111]
 372:Src/aspep.c   ****    /* Data packet the controller can send is bigger than performer can receive */
 1743              		.loc 1 372 3 is_stmt 1 view .LVU612
 372:Src/aspep.c   ****    /* Data packet the controller can send is bigger than performer can receive */
 1744              		.loc 1 372 6 is_stmt 0 view .LVU613
 1745 013c 40F29380 		bls	.L110
 1746              	.LVL132:
 1747              	.L87:
 372:Src/aspep.c   ****    /* Data packet the controller can send is bigger than performer can receive */
 1748              		.loc 1 372 6 view .LVU614
 1749 0140 84F86450 		strb	r5, [r4, #100]
 1750              	.LVL133:
 1751              	.L101:
 372:Src/aspep.c   ****    /* Data packet the controller can send is bigger than performer can receive */
 1752              		.loc 1 372 6 view .LVU615
 1753              	.LBE182:
 1754              	.LBE181:
 764:Src/aspep.c   ****           }
 1755              		.loc 1 764 13 is_stmt 1 view .LVU616
 1756 0144 04F16C01 		add	r1, r4, #108
ARM GAS  /tmp/ccJS0l1g.s 			page 59


 1757 0148 2046     		mov	r0, r4
 1758 014a FFF7FEFF 		bl	ASPEP_sendBeacon
 1759              	.LVL134:
 670:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 1760              		.loc 1 670 12 is_stmt 0 view .LVU617
 1761 014e 0025     		movs	r5, #0
 1762 0150 72E7     		b	.L79
 1763              	.LVL135:
 1764              	.L107:
 1765              	.LBB184:
 1766              	.LBB180:
 241:Src/aspep.c   **** }
 1767              		.loc 1 241 51 view .LVU618
 1768 0152 00F12001 		add	r1, r0, #32
 1769              	.LBB179:
 1770              	.LBB178:
 495:Src/aspep.c   ****       {
 1771              		.loc 1 495 7 is_stmt 1 view .LVU619
 504:Src/aspep.c   ****       {
 1772              		.loc 1 504 12 view .LVU620
 511:Src/aspep.c   ****         pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 1773              		.loc 1 511 9 view .LVU621
 511:Src/aspep.c   ****         pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 1774              		.loc 1 511 35 is_stmt 0 view .LVU622
 1775 0156 0323     		movs	r3, #3
 512:Src/aspep.c   ****       }
 1776              		.loc 1 512 29 view .LVU623
 1777 0158 8164     		str	r1, [r0, #72]
 511:Src/aspep.c   ****         pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 1778              		.loc 1 511 35 view .LVU624
 1779 015a 80F82430 		strb	r3, [r0, #36]
 512:Src/aspep.c   ****       }
 1780              		.loc 1 512 9 is_stmt 1 view .LVU625
 515:Src/aspep.c   ****       pHandle->fASPEP_cfg_trans(pHandle->ASPEPIp, txBuffer, bufferLength);
 1781              		.loc 1 515 7 view .LVU626
 1782              	.LBB176:
 1783              	.LBI176:
 196:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 1784              		.loc 2 196 27 view .LVU627
 1785              	.LBB177:
 198:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 1786              		.loc 2 198 3 view .LVU628
 1787              		.syntax unified
 1788              	@ 198 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1789 015e 62B6     		cpsie i
 1790              	@ 0 "" 2
 1791              		.thumb
 1792              		.syntax unified
 1793              	.LBE177:
 1794              	.LBE176:
 516:Src/aspep.c   ****     }
 1795              		.loc 1 516 7 view .LVU629
 1796 0160 0422     		movs	r2, #4
 1797 0162 836D     		ldr	r3, [r0, #88]
 1798 0164 4069     		ldr	r0, [r0, #20]
 1799              	.LVL136:
 516:Src/aspep.c   ****     }
ARM GAS  /tmp/ccJS0l1g.s 			page 60


 1800              		.loc 1 516 7 is_stmt 0 view .LVU630
 1801 0166 9847     		blx	r3
 1802              	.LVL137:
 516:Src/aspep.c   ****     }
 1803              		.loc 1 516 7 view .LVU631
 1804 0168 A2E7     		b	.L91
 1805              	.LVL138:
 1806              	.L106:
 516:Src/aspep.c   ****     }
 1807              		.loc 1 516 7 view .LVU632
 1808              	.LBE178:
 1809              	.LBE179:
 1810              	.LBE180:
 1811              	.LBE184:
 727:Src/aspep.c   ****             {
 1812              		.loc 1 727 13 is_stmt 1 view .LVU633
 1813              	.LBB185:
 1814              	.LBI185:
 355:Src/aspep.c   **** {
 1815              		.loc 1 355 6 view .LVU634
 1816              	.LBB186:
 357:Src/aspep.c   **** 
 1817              		.loc 1 357 3 view .LVU635
 359:Src/aspep.c   ****   ASPEP_Capabilities_def MasterCapabilities;
 1818              		.loc 1 359 3 view .LVU636
 360:Src/aspep.c   ****   MasterCapabilities.version = (uint8_t)((packetHeader &0x70U)>> 4U);           /*Bits 4 to 6*/
 1819              		.loc 1 360 3 view .LVU637
 361:Src/aspep.c   ****   MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 1820              		.loc 1 361 3 view .LVU638
 362:Src/aspep.c   ****   MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 1821              		.loc 1 362 3 view .LVU639
 362:Src/aspep.c   ****   MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 1822              		.loc 1 362 31 is_stmt 0 view .LVU640
 1823 016a 037F     		ldrb	r3, [r0, #28]	@ zero_extendqisi2
 367:Src/aspep.c   ****   pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_ma
 1824              		.loc 1 367 36 view .LVU641
 1825 016c 94F86C50 		ldrb	r5, [r4, #108]	@ zero_extendqisi2
 363:Src/aspep.c   ****   MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
 1826              		.loc 1 363 56 view .LVU642
 1827 0170 407F     		ldrb	r0, [r0, #29]	@ zero_extendqisi2
 1828              	.LVL139:
 368:Src/aspep.c   ****   pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS
 1829              		.loc 1 368 38 view .LVU643
 1830 0172 94F86D10 		ldrb	r1, [r4, #109]	@ zero_extendqisi2
 369:Src/aspep.c   ****   pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA
 1831              		.loc 1 369 39 view .LVU644
 1832 0176 94F86E60 		ldrb	r6, [r4, #110]	@ zero_extendqisi2
 370:Src/aspep.c   **** 
 1833              		.loc 1 370 39 view .LVU645
 1834 017a 94F86FC0 		ldrb	ip, [r4, #111]	@ zero_extendqisi2
 362:Src/aspep.c   ****   MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 1835              		.loc 1 362 31 view .LVU646
 1836 017e DB09     		lsrs	r3, r3, #7
 1837              	.LVL140:
 363:Src/aspep.c   ****   MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
 1838              		.loc 1 363 3 is_stmt 1 view .LVU647
 363:Src/aspep.c   ****   MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
ARM GAS  /tmp/ccJS0l1g.s 			page 61


 1839              		.loc 1 363 56 is_stmt 0 view .LVU648
 1840 0180 00F03F00 		and	r0, r0, #63
 1841              	.LVL141:
 364:Src/aspep.c   ****   MasterCapabilities.TXA_maxSize = (uint8_t)((packetHeader&0xFE00000U) >> 21);  /*Bits 21 to 27  */
 1842              		.loc 1 364 3 is_stmt 1 view .LVU649
 367:Src/aspep.c   ****   pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_ma
 1843              		.loc 1 367 36 is_stmt 0 view .LVU650
 1844 0184 AB42     		cmp	r3, r5
 1845 0186 9846     		mov	r8, r3
 364:Src/aspep.c   ****   MasterCapabilities.TXA_maxSize = (uint8_t)((packetHeader&0xFE00000U) >> 21);  /*Bits 21 to 27  */
 1846              		.loc 1 364 36 view .LVU651
 1847 0188 C2F38637 		ubfx	r7, r2, #14, #7
 1848              	.LVL142:
 365:Src/aspep.c   **** 
 1849              		.loc 1 365 3 is_stmt 1 view .LVU652
 367:Src/aspep.c   ****   pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_ma
 1850              		.loc 1 367 36 is_stmt 0 view .LVU653
 1851 018c 28BF     		it	cs
 1852 018e A846     		movcs	r8, r5
 368:Src/aspep.c   ****   pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS
 1853              		.loc 1 368 38 view .LVU654
 1854 0190 8142     		cmp	r1, r0
 365:Src/aspep.c   **** 
 1855              		.loc 1 365 36 view .LVU655
 1856 0192 C2F3465E 		ubfx	lr, r2, #21, #7
 1857              	.LVL143:
 367:Src/aspep.c   ****   pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_ma
 1858              		.loc 1 367 3 is_stmt 1 view .LVU656
 368:Src/aspep.c   ****   pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS
 1859              		.loc 1 368 38 is_stmt 0 view .LVU657
 1860 0196 28BF     		it	cs
 1861 0198 0146     		movcs	r1, r0
 369:Src/aspep.c   ****   pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA
 1862              		.loc 1 369 39 view .LVU658
 1863 019a B742     		cmp	r7, r6
 1864 019c B946     		mov	r9, r7
 1865 019e 28BF     		it	cs
 1866 01a0 B146     		movcs	r9, r6
 370:Src/aspep.c   **** 
 1867              		.loc 1 370 39 view .LVU659
 1868 01a2 E645     		cmp	lr, ip
 367:Src/aspep.c   ****   pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_ma
 1869              		.loc 1 367 34 view .LVU660
 1870 01a4 84F86C80 		strb	r8, [r4, #108]
 368:Src/aspep.c   ****   pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS
 1871              		.loc 1 368 3 is_stmt 1 view .LVU661
 370:Src/aspep.c   **** 
 1872              		.loc 1 370 39 is_stmt 0 view .LVU662
 1873 01a8 F046     		mov	r8, lr
 1874 01aa 28BF     		it	cs
 1875 01ac E046     		movcs	r8, ip
 372:Src/aspep.c   ****    /* Data packet the controller can send is bigger than performer can receive */
 1876              		.loc 1 372 6 view .LVU663
 1877 01ae AB42     		cmp	r3, r5
 368:Src/aspep.c   ****   pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS
 1878              		.loc 1 368 36 view .LVU664
 1879 01b0 84F86D10 		strb	r1, [r4, #109]
ARM GAS  /tmp/ccJS0l1g.s 			page 62


 369:Src/aspep.c   ****   pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA
 1880              		.loc 1 369 3 is_stmt 1 view .LVU665
 369:Src/aspep.c   ****   pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA
 1881              		.loc 1 369 37 is_stmt 0 view .LVU666
 1882 01b4 84F86E90 		strb	r9, [r4, #110]
 370:Src/aspep.c   **** 
 1883              		.loc 1 370 3 is_stmt 1 view .LVU667
 370:Src/aspep.c   **** 
 1884              		.loc 1 370 37 is_stmt 0 view .LVU668
 1885 01b8 84F86F80 		strb	r8, [r4, #111]
 372:Src/aspep.c   ****    /* Data packet the controller can send is bigger than performer can receive */
 1886              		.loc 1 372 3 is_stmt 1 view .LVU669
 372:Src/aspep.c   ****    /* Data packet the controller can send is bigger than performer can receive */
 1887              		.loc 1 372 6 is_stmt 0 view .LVU670
 1888 01bc 64D9     		bls	.L111
 1889              	.LVL144:
 1890              	.L85:
 384:Src/aspep.c   ****   }
 1891              		.loc 1 384 5 is_stmt 1 view .LVU671
 391:Src/aspep.c   **** }
 1892              		.loc 1 391 3 view .LVU672
 391:Src/aspep.c   **** }
 1893              		.loc 1 391 3 is_stmt 0 view .LVU673
 1894              	.LBE186:
 1895              	.LBE185:
 729:Src/aspep.c   ****             }
 1896              		.loc 1 729 15 is_stmt 1 view .LVU674
 729:Src/aspep.c   ****             }
 1897              		.loc 1 729 36 is_stmt 0 view .LVU675
 1898 01be 0023     		movs	r3, #0
 1899 01c0 84F86430 		strb	r3, [r4, #100]
 1900 01c4 BEE7     		b	.L101
 1901              	.LVL145:
 1902              	.L108:
 695:Src/aspep.c   ****             {
 1903              		.loc 1 695 13 is_stmt 1 view .LVU676
 1904              	.LBB188:
 1905              	.LBI188:
 355:Src/aspep.c   **** {
 1906              		.loc 1 355 6 view .LVU677
 1907              	.LBB189:
 357:Src/aspep.c   **** 
 1908              		.loc 1 357 3 view .LVU678
 359:Src/aspep.c   ****   ASPEP_Capabilities_def MasterCapabilities;
 1909              		.loc 1 359 3 view .LVU679
 360:Src/aspep.c   ****   MasterCapabilities.version = (uint8_t)((packetHeader &0x70U)>> 4U);           /*Bits 4 to 6*/
 1910              		.loc 1 360 3 view .LVU680
 361:Src/aspep.c   ****   MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 1911              		.loc 1 361 3 view .LVU681
 362:Src/aspep.c   ****   MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 1912              		.loc 1 362 3 view .LVU682
 362:Src/aspep.c   ****   MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 1913              		.loc 1 362 31 is_stmt 0 view .LVU683
 1914 01c6 017F     		ldrb	r1, [r0, #28]	@ zero_extendqisi2
 1915              	.LVL146:
 367:Src/aspep.c   ****   pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_ma
 1916              		.loc 1 367 36 view .LVU684
ARM GAS  /tmp/ccJS0l1g.s 			page 63


 1917 01c8 90F86C70 		ldrb	r7, [r0, #108]	@ zero_extendqisi2
 363:Src/aspep.c   ****   MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
 1918              		.loc 1 363 56 view .LVU685
 1919 01cc 457F     		ldrb	r5, [r0, #29]	@ zero_extendqisi2
 368:Src/aspep.c   ****   pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS
 1920              		.loc 1 368 38 view .LVU686
 1921 01ce 90F86D30 		ldrb	r3, [r0, #109]	@ zero_extendqisi2
 369:Src/aspep.c   ****   pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA
 1922              		.loc 1 369 39 view .LVU687
 1923 01d2 90F86EC0 		ldrb	ip, [r0, #110]	@ zero_extendqisi2
 370:Src/aspep.c   **** 
 1924              		.loc 1 370 39 view .LVU688
 1925 01d6 90F86F80 		ldrb	r8, [r0, #111]	@ zero_extendqisi2
 362:Src/aspep.c   ****   MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 1926              		.loc 1 362 31 view .LVU689
 1927 01da C909     		lsrs	r1, r1, #7
 1928              	.LVL147:
 363:Src/aspep.c   ****   MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
 1929              		.loc 1 363 3 is_stmt 1 view .LVU690
 363:Src/aspep.c   ****   MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
 1930              		.loc 1 363 56 is_stmt 0 view .LVU691
 1931 01dc 05F03F05 		and	r5, r5, #63
 1932              	.LVL148:
 364:Src/aspep.c   ****   MasterCapabilities.TXA_maxSize = (uint8_t)((packetHeader&0xFE00000U) >> 21);  /*Bits 21 to 27  */
 1933              		.loc 1 364 3 is_stmt 1 view .LVU692
 367:Src/aspep.c   ****   pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_ma
 1934              		.loc 1 367 36 is_stmt 0 view .LVU693
 1935 01e0 B942     		cmp	r1, r7
 364:Src/aspep.c   ****   MasterCapabilities.TXA_maxSize = (uint8_t)((packetHeader&0xFE00000U) >> 21);  /*Bits 21 to 27  */
 1936              		.loc 1 364 36 view .LVU694
 1937 01e2 C2F3863E 		ubfx	lr, r2, #14, #7
 1938              	.LVL149:
 365:Src/aspep.c   **** 
 1939              		.loc 1 365 3 is_stmt 1 view .LVU695
 367:Src/aspep.c   ****   pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_ma
 1940              		.loc 1 367 36 is_stmt 0 view .LVU696
 1941 01e6 8A46     		mov	r10, r1
 1942 01e8 28BF     		it	cs
 1943 01ea BA46     		movcs	r10, r7
 368:Src/aspep.c   ****   pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS
 1944              		.loc 1 368 38 view .LVU697
 1945 01ec AB42     		cmp	r3, r5
 365:Src/aspep.c   **** 
 1946              		.loc 1 365 36 view .LVU698
 1947 01ee C2F34659 		ubfx	r9, r2, #21, #7
 1948              	.LVL150:
 367:Src/aspep.c   ****   pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_ma
 1949              		.loc 1 367 3 is_stmt 1 view .LVU699
 368:Src/aspep.c   ****   pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS
 1950              		.loc 1 368 38 is_stmt 0 view .LVU700
 1951 01f2 28BF     		it	cs
 1952 01f4 2B46     		movcs	r3, r5
 369:Src/aspep.c   ****   pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA
 1953              		.loc 1 369 39 view .LVU701
 1954 01f6 E645     		cmp	lr, ip
 1955 01f8 7046     		mov	r0, lr
 1956              	.LVL151:
ARM GAS  /tmp/ccJS0l1g.s 			page 64


 369:Src/aspep.c   ****   pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA
 1957              		.loc 1 369 39 view .LVU702
 1958 01fa 28BF     		it	cs
 1959 01fc 6046     		movcs	r0, ip
 370:Src/aspep.c   **** 
 1960              		.loc 1 370 39 view .LVU703
 1961 01fe C145     		cmp	r9, r8
 1962 0200 4E46     		mov	r6, r9
 1963 0202 28BF     		it	cs
 1964 0204 4646     		movcs	r6, r8
 372:Src/aspep.c   ****    /* Data packet the controller can send is bigger than performer can receive */
 1965              		.loc 1 372 6 view .LVU704
 1966 0206 B942     		cmp	r1, r7
 367:Src/aspep.c   ****   pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_ma
 1967              		.loc 1 367 34 view .LVU705
 1968 0208 84F86CA0 		strb	r10, [r4, #108]
 368:Src/aspep.c   ****   pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS
 1969              		.loc 1 368 3 is_stmt 1 view .LVU706
 368:Src/aspep.c   ****   pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS
 1970              		.loc 1 368 36 is_stmt 0 view .LVU707
 1971 020c 84F86D30 		strb	r3, [r4, #109]
 369:Src/aspep.c   ****   pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA
 1972              		.loc 1 369 3 is_stmt 1 view .LVU708
 369:Src/aspep.c   ****   pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA
 1973              		.loc 1 369 37 is_stmt 0 view .LVU709
 1974 0210 84F86E00 		strb	r0, [r4, #110]
 370:Src/aspep.c   **** 
 1975              		.loc 1 370 3 is_stmt 1 view .LVU710
 370:Src/aspep.c   **** 
 1976              		.loc 1 370 37 is_stmt 0 view .LVU711
 1977 0214 84F86F60 		strb	r6, [r4, #111]
 372:Src/aspep.c   ****    /* Data packet the controller can send is bigger than performer can receive */
 1978              		.loc 1 372 3 is_stmt 1 view .LVU712
 372:Src/aspep.c   ****    /* Data packet the controller can send is bigger than performer can receive */
 1979              		.loc 1 372 6 is_stmt 0 view .LVU713
 1980 0218 94D8     		bhi	.L101
 374:Src/aspep.c   ****    /* Sync packet size alignement is required in order for the controller to be able to store it, a
 1981              		.loc 1 374 4 view .LVU714
 1982 021a 9D42     		cmp	r5, r3
 1983 021c 92D8     		bhi	.L101
 377:Src/aspep.c   ****    /* Async packet the performer can send is bigger than the controller can receive (but controller
 1984              		.loc 1 377 4 view .LVU715
 1985 021e E645     		cmp	lr, ip
 1986 0220 90D8     		bhi	.L101
 380:Src/aspep.c   ****    /* For the time being, controller version has to match performer version */
 1987              		.loc 1 380 4 view .LVU716
 1988 0222 C145     		cmp	r9, r8
 1989 0224 8ED8     		bhi	.L101
 382:Src/aspep.c   ****   {
 1990              		.loc 1 382 4 view .LVU717
 1991 0226 94F87010 		ldrb	r1, [r4, #112]	@ zero_extendqisi2
 1992              	.LVL152:
 382:Src/aspep.c   ****   {
 1993              		.loc 1 382 4 view .LVU718
 1994 022a C2F30212 		ubfx	r2, r2, #4, #3
 1995              	.LVL153:
 382:Src/aspep.c   ****   {
ARM GAS  /tmp/ccJS0l1g.s 			page 65


 1996              		.loc 1 382 4 view .LVU719
 1997 022e 9142     		cmp	r1, r2
 1998 0230 88D1     		bne	.L101
 391:Src/aspep.c   **** }
 1999              		.loc 1 391 3 is_stmt 1 view .LVU720
 2000              	.LVL154:
 391:Src/aspep.c   **** }
 2001              		.loc 1 391 3 is_stmt 0 view .LVU721
 2002              	.LBE189:
 2003              	.LBE188:
 698:Src/aspep.c   ****               pSupHandle->txAsyncMaxPayload = (pHandle->Capabilities.TXA_maxSize) * (uint16_t)64U;
 2004              		.loc 1 698 15 is_stmt 1 view .LVU722
 698:Src/aspep.c   ****               pSupHandle->txAsyncMaxPayload = (pHandle->Capabilities.TXA_maxSize) * (uint16_t)64U;
 2005              		.loc 1 698 81 is_stmt 0 view .LVU723
 2006 0232 421C     		adds	r2, r0, #1
 700:Src/aspep.c   ****               pHandle->ASPEP_State = ASPEP_CONFIGURED;
 2007              		.loc 1 700 73 view .LVU724
 2008 0234 0133     		adds	r3, r3, #1
 698:Src/aspep.c   ****               pSupHandle->txAsyncMaxPayload = (pHandle->Capabilities.TXA_maxSize) * (uint16_t)64U;
 2009              		.loc 1 698 44 view .LVU725
 2010 0236 5201     		lsls	r2, r2, #5
 700:Src/aspep.c   ****               pHandle->ASPEP_State = ASPEP_CONFIGURED;
 2011              		.loc 1 700 37 view .LVU726
 2012 0238 5B01     		lsls	r3, r3, #5
 699:Src/aspep.c   ****               pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t
 2013              		.loc 1 699 45 view .LVU727
 2014 023a B601     		lsls	r6, r6, #6
 701:Src/aspep.c   ****             }
 2015              		.loc 1 701 36 view .LVU728
 2016 023c 0121     		movs	r1, #1
 698:Src/aspep.c   ****               pSupHandle->txAsyncMaxPayload = (pHandle->Capabilities.TXA_maxSize) * (uint16_t)64U;
 2017              		.loc 1 698 44 view .LVU729
 2018 023e A281     		strh	r2, [r4, #12]	@ movhi
 699:Src/aspep.c   ****               pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t
 2019              		.loc 1 699 15 is_stmt 1 view .LVU730
 700:Src/aspep.c   ****               pHandle->ASPEP_State = ASPEP_CONFIGURED;
 2020              		.loc 1 700 37 is_stmt 0 view .LVU731
 2021 0240 A4F85E30 		strh	r3, [r4, #94]	@ movhi
 699:Src/aspep.c   ****               pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t
 2022              		.loc 1 699 45 view .LVU732
 2023 0244 E681     		strh	r6, [r4, #14]	@ movhi
 700:Src/aspep.c   ****               pHandle->ASPEP_State = ASPEP_CONFIGURED;
 2024              		.loc 1 700 15 is_stmt 1 view .LVU733
 701:Src/aspep.c   ****             }
 2025              		.loc 1 701 15 view .LVU734
 701:Src/aspep.c   ****             }
 2026              		.loc 1 701 36 is_stmt 0 view .LVU735
 2027 0246 84F86410 		strb	r1, [r4, #100]
 2028 024a 7BE7     		b	.L101
 2029              	.LVL155:
 2030              	.L103:
 768:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 2031              		.loc 1 768 13 is_stmt 1 view .LVU736
 769:Src/aspep.c   ****           }
 2032              		.loc 1 769 13 view .LVU737
 2033 024c C2F30F32 		ubfx	r2, r2, #12, #16
 2034              	.LVL156:
ARM GAS  /tmp/ccJS0l1g.s 			page 66


 769:Src/aspep.c   ****           }
 2035              		.loc 1 769 13 is_stmt 0 view .LVU738
 2036 0250 0121     		movs	r1, #1
 2037              	.LVL157:
 769:Src/aspep.c   ****           }
 2038              		.loc 1 769 13 view .LVU739
 2039 0252 FFF7FEFF 		bl	ASPEP_sendPing
 2040              	.LVL158:
 769:Src/aspep.c   ****           }
 2041              		.loc 1 769 13 view .LVU740
 2042 0256 EFE6     		b	.L79
 2043              	.LVL159:
 2044              	.L109:
 713:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_RESET, packetNumber);
 2045              		.loc 1 713 13 is_stmt 1 view .LVU741
 714:Src/aspep.c   ****           }
 2046              		.loc 1 714 13 view .LVU742
 2047 0258 C2F30F32 		ubfx	r2, r2, #12, #16
 2048              	.LVL160:
 714:Src/aspep.c   ****           }
 2049              		.loc 1 714 13 is_stmt 0 view .LVU743
 2050 025c 3146     		mov	r1, r6
 2051              	.LVL161:
 714:Src/aspep.c   ****           }
 2052              		.loc 1 714 13 view .LVU744
 2053 025e FFF7FEFF 		bl	ASPEP_sendPing
 2054              	.LVL162:
 670:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 2055              		.loc 1 670 12 view .LVU745
 2056 0262 3546     		mov	r5, r6
 2057 0264 E8E6     		b	.L79
 2058              	.LVL163:
 2059              	.L110:
 2060              	.LBB190:
 2061              	.LBB183:
 374:Src/aspep.c   ****    /* Sync packet size alignement is required in order for the controller to be able to store it, a
 2062              		.loc 1 374 4 view .LVU746
 2063 0266 8842     		cmp	r0, r1
 2064 0268 3FF66AAF 		bhi	.L87
 377:Src/aspep.c   ****    /* Async packet the performer can send is bigger than the controller can receive (but controller
 2065              		.loc 1 377 4 view .LVU747
 2066 026c BC45     		cmp	ip, r7
 2067 026e 3FF667AF 		bhi	.L87
 380:Src/aspep.c   ****    /* For the time being, controller version has to match performer version */
 2068              		.loc 1 380 4 view .LVU748
 2069 0272 F045     		cmp	r8, lr
 2070 0274 3FF664AF 		bhi	.L87
 382:Src/aspep.c   ****   {
 2071              		.loc 1 382 4 view .LVU749
 2072 0278 94F87050 		ldrb	r5, [r4, #112]	@ zero_extendqisi2
 2073 027c C2F30212 		ubfx	r2, r2, #4, #3
 2074              	.LVL164:
 382:Src/aspep.c   ****   {
 2075              		.loc 1 382 4 view .LVU750
 2076              	.LBE183:
 2077              	.LBE190:
 758:Src/aspep.c   ****             }
ARM GAS  /tmp/ccJS0l1g.s 			page 67


 2078              		.loc 1 758 36 view .LVU751
 2079 0280 AB1A     		subs	r3, r5, r2
 2080              	.LVL165:
 758:Src/aspep.c   ****             }
 2081              		.loc 1 758 36 view .LVU752
 2082 0282 5D42     		rsbs	r5, r3, #0
 2083 0284 5D41     		adcs	r5, r5, r3
 2084 0286 5BE7     		b	.L87
 2085              	.LVL166:
 2086              	.L111:
 2087              	.LBB191:
 2088              	.LBB187:
 374:Src/aspep.c   ****    /* Sync packet size alignement is required in order for the controller to be able to store it, a
 2089              		.loc 1 374 4 view .LVU753
 2090 0288 8842     		cmp	r0, r1
 2091 028a 98D8     		bhi	.L85
 377:Src/aspep.c   ****    /* Async packet the performer can send is bigger than the controller can receive (but controller
 2092              		.loc 1 377 4 view .LVU754
 2093 028c B742     		cmp	r7, r6
 2094 028e 96D8     		bhi	.L85
 380:Src/aspep.c   ****    /* For the time being, controller version has to match performer version */
 2095              		.loc 1 380 4 view .LVU755
 2096 0290 E645     		cmp	lr, ip
 2097 0292 94D8     		bhi	.L85
 382:Src/aspep.c   ****   {
 2098              		.loc 1 382 4 view .LVU756
 2099 0294 94F87030 		ldrb	r3, [r4, #112]	@ zero_extendqisi2
 2100              	.LVL167:
 382:Src/aspep.c   ****   {
 2101              		.loc 1 382 4 view .LVU757
 2102 0298 C2F30212 		ubfx	r2, r2, #4, #3
 2103              	.LVL168:
 382:Src/aspep.c   ****   {
 2104              		.loc 1 382 4 view .LVU758
 2105 029c 9342     		cmp	r3, r2
 2106 029e 8ED1     		bne	.L85
 2107 02a0 50E7     		b	.L101
 2108              	.L113:
 2109 02a2 00BF     		.align	2
 2110              	.L112:
 2111 02a4 00000000 		.word	.LANCHOR0
 2112 02a8 00000000 		.word	.LANCHOR1
 2113              	.LBE187:
 2114              	.LBE191:
 2115              		.cfi_endproc
 2116              	.LFE1448:
 2118              		.section	.text.ASPEP_HWDataReceivedIT,"ax",%progbits
 2119              		.align	1
 2120              		.p2align 2,,3
 2121              		.global	ASPEP_HWDataReceivedIT
 2122              		.syntax unified
 2123              		.thumb
 2124              		.thumb_func
 2125              		.fpu fpv4-sp-d16
 2127              	ASPEP_HWDataReceivedIT:
 2128              	.LVL169:
 2129              	.LFB1449:
ARM GAS  /tmp/ccJS0l1g.s 			page 68


 825:Src/aspep.c   **** 
 826:Src/aspep.c   **** /**
 827:Src/aspep.c   ****   * @brief  Processes the received data packet.
 828:Src/aspep.c   ****   *
 829:Src/aspep.c   ****   * This function is called once DMA has transfered the configure number of byte.
 830:Src/aspep.c   ****   * Upon reception of a new packet the DMA will be re-configured only once the answer has been sent
 831:Src/aspep.c   ****   * This is mandatory to avoid a race condition in case of a new packet is received while executing
 832:Src/aspep.c   ****   * If the packet received contains an error in the header, the HW IP will be re-synchronised first
 833:Src/aspep.c   ****   *
 834:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 835:Src/aspep.c   ****   */
 836:Src/aspep.c   **** void ASPEP_HWDataReceivedIT(ASPEP_Handle_t *pHandle)
 837:Src/aspep.c   **** {
 2130              		.loc 1 837 1 is_stmt 1 view -0
 2131              		.cfi_startproc
 2132              		@ args = 0, pretend = 0, frame = 0
 2133              		@ frame_needed = 0, uses_anonymous_args = 0
 838:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 839:Src/aspep.c   ****   if (MC_NULL == pHandle)
 840:Src/aspep.c   ****   {
 841:Src/aspep.c   ****     /* Nothing to do */
 842:Src/aspep.c   ****   }
 843:Src/aspep.c   ****   else
 844:Src/aspep.c   ****   {
 845:Src/aspep.c   **** #endif
 846:Src/aspep.c   ****     switch (pHandle->ASPEP_TL_State)
 2134              		.loc 1 846 5 view .LVU760
 837:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 2135              		.loc 1 837 1 is_stmt 0 view .LVU761
 2136 0000 38B5     		push	{r3, r4, r5, lr}
 2137              	.LCFI21:
 2138              		.cfi_def_cfa_offset 16
 2139              		.cfi_offset 3, -16
 2140              		.cfi_offset 4, -12
 2141              		.cfi_offset 5, -8
 2142              		.cfi_offset 14, -4
 2143              		.loc 1 846 20 view .LVU762
 2144 0002 90F86530 		ldrb	r3, [r0, #101]	@ zero_extendqisi2
 2145              		.loc 1 846 5 view .LVU763
 2146 0006 3BB1     		cbz	r3, .L115
 2147 0008 012B     		cmp	r3, #1
 2148 000a 04D1     		bne	.L114
 847:Src/aspep.c   ****     {
 848:Src/aspep.c   ****       case WAITING_PACKET:
 849:Src/aspep.c   ****       {
 850:Src/aspep.c   ****         if (ASPEP_CheckHeaderCRC(*(uint32_t *)pHandle->rxHeader) == true) //cstat !MISRAC2012-Rule-
 851:Src/aspep.c   ****         {
 852:Src/aspep.c   ****           pHandle->rxPacketType = (ASPEP_packetType)(((uint32_t)pHandle->rxHeader[0]) & ID_MASK);
 853:Src/aspep.c   ****           switch (pHandle->rxPacketType)
 854:Src/aspep.c   ****           {
 855:Src/aspep.c   ****             case DATA_PACKET:
 856:Src/aspep.c   ****             {
 857:Src/aspep.c   ****               //cstat !MISRAC2012-Rule-11.3
 858:Src/aspep.c   ****               pHandle->rxLengthASPEP = (uint16_t)((*((uint16_t *)pHandle->rxHeader) & 0x1FFF0U) >> 
 859:Src/aspep.c   ****               if (0U == pHandle->rxLengthASPEP) /* data packet with length 0 is a valid packet */
 860:Src/aspep.c   ****               {
 861:Src/aspep.c   ****                 pHandle->NewPacketAvailable = true;
ARM GAS  /tmp/ccJS0l1g.s 			page 69


 862:Src/aspep.c   ****                 /* The receiver is not reconfigure right now on purpose to avoid race condition whe
 863:Src/aspep.c   ****                   *  processed in ASPEP_RXframeProcess */
 864:Src/aspep.c   ****               }
 865:Src/aspep.c   ****               else if (pHandle->rxLengthASPEP <= pHandle->maxRXPayload)
 866:Src/aspep.c   ****               {
 867:Src/aspep.c   ****                 pHandle->fASPEP_cfg_recept(pHandle->ASPEPIp, pHandle->rxBuffer,  /* need to read + 
 868:Src/aspep.c   ****                                         (pHandle->rxLengthASPEP + ((uint16_t)ASPEP_DATACRC_SIZE * (
 869:Src/aspep.c   ****                 pHandle->ASPEP_TL_State = WAITING_PAYLOAD;
 870:Src/aspep.c   ****               }
 871:Src/aspep.c   ****               else
 872:Src/aspep.c   ****               {
 873:Src/aspep.c   ****                 pHandle->badPacketFlag = ASPEP_BAD_PACKET_SIZE;
 874:Src/aspep.c   ****               }
 875:Src/aspep.c   ****               break;
 876:Src/aspep.c   ****             }
 877:Src/aspep.c   **** 
 878:Src/aspep.c   ****             case BEACON:
 879:Src/aspep.c   ****             case PING:
 880:Src/aspep.c   ****             {
 881:Src/aspep.c   ****               pHandle->NewPacketAvailable = true;
 882:Src/aspep.c   ****               /* The receiver is not reconfigure right now on purpose to avoid race condition when 
 883:Src/aspep.c   ****                 * processed in ASPEP_RXframeProcess */
 884:Src/aspep.c   ****               break;
 885:Src/aspep.c   ****             }
 886:Src/aspep.c   **** 
 887:Src/aspep.c   ****             default:
 888:Src/aspep.c   ****             {
 889:Src/aspep.c   ****               pHandle->badPacketFlag = ASPEP_BAD_PACKET_TYPE;
 890:Src/aspep.c   ****               break;
 891:Src/aspep.c   ****             }
 892:Src/aspep.c   ****           }
 893:Src/aspep.c   ****         }
 894:Src/aspep.c   ****         else
 895:Src/aspep.c   ****         {
 896:Src/aspep.c   ****           pHandle->badPacketFlag = ASPEP_BAD_CRC_HEADER;
 897:Src/aspep.c   ****         }
 898:Src/aspep.c   ****         break;
 899:Src/aspep.c   ****       }
 900:Src/aspep.c   **** 
 901:Src/aspep.c   ****       case WAITING_PAYLOAD:
 902:Src/aspep.c   ****       {
 903:Src/aspep.c   ****         pHandle->ASPEP_TL_State = WAITING_PACKET;
 2149              		.loc 1 903 9 is_stmt 1 view .LVU764
 2150              		.loc 1 903 33 is_stmt 0 view .LVU765
 2151 000c 0022     		movs	r2, #0
 904:Src/aspep.c   ****         /* Payload received, */
 905:Src/aspep.c   ****         pHandle->NewPacketAvailable = true;
 2152              		.loc 1 905 37 view .LVU766
 2153 000e 80F86130 		strb	r3, [r0, #97]
 903:Src/aspep.c   ****         /* Payload received, */
 2154              		.loc 1 903 33 view .LVU767
 2155 0012 80F86520 		strb	r2, [r0, #101]
 2156              		.loc 1 905 9 is_stmt 1 view .LVU768
 906:Src/aspep.c   ****         /* The receiver is not reconfigure right now on purpose to avoid race condition when the pa
 907:Src/aspep.c   ****           * processed in ASPEP_RXframeProcess */
 908:Src/aspep.c   ****         break;
 2157              		.loc 1 908 9 view .LVU769
ARM GAS  /tmp/ccJS0l1g.s 			page 70


 2158              	.L114:
 909:Src/aspep.c   ****       }
 910:Src/aspep.c   **** 
 911:Src/aspep.c   ****       default:
 912:Src/aspep.c   ****         break;
 913:Src/aspep.c   ****     }
 914:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 915:Src/aspep.c   ****   }
 916:Src/aspep.c   **** #endif
 917:Src/aspep.c   **** }
 2159              		.loc 1 917 1 is_stmt 0 view .LVU770
 2160 0016 38BD     		pop	{r3, r4, r5, pc}
 2161              	.L115:
 850:Src/aspep.c   ****         {
 2162              		.loc 1 850 9 is_stmt 1 view .LVU771
 850:Src/aspep.c   ****         {
 2163              		.loc 1 850 13 is_stmt 0 view .LVU772
 2164 0018 C169     		ldr	r1, [r0, #28]
 2165              	.LVL170:
 2166              	.LBB192:
 2167              	.LBI192:
 152:Src/aspep.c   **** {
 2168              		.loc 1 152 13 is_stmt 1 view .LVU773
 2169              	.LBB193:
 154:Src/aspep.c   **** 
 2170              		.loc 1 154 3 view .LVU774
 157:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 2171              		.loc 1 157 3 view .LVU775
 158:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 2172              		.loc 1 158 3 view .LVU776
 157:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 2173              		.loc 1 157 7 is_stmt 0 view .LVU777
 2174 001a 1F4A     		ldr	r2, .L124
 157:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 2175              		.loc 1 157 26 view .LVU778
 2176 001c CBB2     		uxtb	r3, r1
 158:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 2177              		.loc 1 158 26 view .LVU779
 2178 001e D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 2179 0020 83EA1123 		eor	r3, r3, r1, lsr #8
 2180 0024 DBB2     		uxtb	r3, r3
 2181              	.LVL171:
 159:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 24U) & 0xffU)];
 2182              		.loc 1 159 3 is_stmt 1 view .LVU780
 159:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 24U) & 0xffU)];
 2183              		.loc 1 159 26 is_stmt 0 view .LVU781
 2184 0026 D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 2185              	.LVL172:
 159:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 24U) & 0xffU)];
 2186              		.loc 1 159 26 view .LVU782
 2187 0028 83EA1143 		eor	r3, r3, r1, lsr #16
 2188 002c DBB2     		uxtb	r3, r3
 2189              	.LVL173:
 160:Src/aspep.c   **** #else /* CRC4_PER_NIBBLE */
 2190              		.loc 1 160 3 is_stmt 1 view .LVU783
 160:Src/aspep.c   **** #else /* CRC4_PER_NIBBLE */
 2191              		.loc 1 160 26 is_stmt 0 view .LVU784
ARM GAS  /tmp/ccJS0l1g.s 			page 71


 2192 002e D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 2193              	.LVL174:
 160:Src/aspep.c   **** #else /* CRC4_PER_NIBBLE */
 2194              		.loc 1 160 26 view .LVU785
 2195 0030 83EA1161 		eor	r1, r3, r1, lsr #24
 2196              	.LVL175:
 172:Src/aspep.c   **** }
 2197              		.loc 1 172 3 is_stmt 1 view .LVU786
 172:Src/aspep.c   **** }
 2198              		.loc 1 172 3 is_stmt 0 view .LVU787
 2199              	.LBE193:
 2200              	.LBE192:
 850:Src/aspep.c   ****         {
 2201              		.loc 1 850 12 view .LVU788
 2202 0034 535C     		ldrb	r3, [r2, r1]	@ zero_extendqisi2
 2203 0036 FBB9     		cbnz	r3, .L118
 852:Src/aspep.c   ****           switch (pHandle->rxPacketType)
 2204              		.loc 1 852 11 is_stmt 1 view .LVU789
 2205 0038 037F     		ldrb	r3, [r0, #28]	@ zero_extendqisi2
 2206 003a 03F00F03 		and	r3, r3, #15
 2207 003e 052B     		cmp	r3, #5
 852:Src/aspep.c   ****           switch (pHandle->rxPacketType)
 2208              		.loc 1 852 35 is_stmt 0 view .LVU790
 2209 0040 8366     		str	r3, [r0, #104]
 853:Src/aspep.c   ****           {
 2210              		.loc 1 853 11 is_stmt 1 view .LVU791
 2211 0042 21D3     		bcc	.L119
 2212 0044 062B     		cmp	r3, #6
 2213 0046 1BD9     		bls	.L120
 2214 0048 092B     		cmp	r3, #9
 2215 004a 1DD1     		bne	.L119
 858:Src/aspep.c   ****               if (0U == pHandle->rxLengthASPEP) /* data packet with length 0 is a valid packet */
 2216              		.loc 1 858 15 view .LVU792
 858:Src/aspep.c   ****               if (0U == pHandle->rxLengthASPEP) /* data packet with length 0 is a valid packet */
 2217              		.loc 1 858 97 is_stmt 0 view .LVU793
 2218 004c 838B     		ldrh	r3, [r0, #28]
 2219 004e 1B09     		lsrs	r3, r3, #4
 858:Src/aspep.c   ****               if (0U == pHandle->rxLengthASPEP) /* data packet with length 0 is a valid packet */
 2220              		.loc 1 858 38 view .LVU794
 2221 0050 A0F85C30 		strh	r3, [r0, #92]	@ movhi
 859:Src/aspep.c   ****               {
 2222              		.loc 1 859 15 is_stmt 1 view .LVU795
 859:Src/aspep.c   ****               {
 2223              		.loc 1 859 18 is_stmt 0 view .LVU796
 2224 0054 A3B1     		cbz	r3, .L120
 865:Src/aspep.c   ****               {
 2225              		.loc 1 865 20 is_stmt 1 view .LVU797
 865:Src/aspep.c   ****               {
 2226              		.loc 1 865 23 is_stmt 0 view .LVU798
 2227 0056 B0F85E20 		ldrh	r2, [r0, #94]
 2228 005a 9A42     		cmp	r2, r3
 2229 005c 18D3     		bcc	.L122
 867:Src/aspep.c   ****                                         (pHandle->rxLengthASPEP + ((uint16_t)ASPEP_DATACRC_SIZE * (
 2230              		.loc 1 867 17 is_stmt 1 view .LVU799
 2231 005e 90F86C20 		ldrb	r2, [r0, #108]	@ zero_extendqisi2
 2232 0062 456D     		ldr	r5, [r0, #84]
 2233 0064 0446     		mov	r4, r0
ARM GAS  /tmp/ccJS0l1g.s 			page 72


 2234 0066 03EB4202 		add	r2, r3, r2, lsl #1
 2235 006a D0E90501 		ldrd	r0, r1, [r0, #20]
 2236              	.LVL176:
 867:Src/aspep.c   ****                                         (pHandle->rxLengthASPEP + ((uint16_t)ASPEP_DATACRC_SIZE * (
 2237              		.loc 1 867 17 is_stmt 0 view .LVU800
 2238 006e A847     		blx	r5
 2239              	.LVL177:
 869:Src/aspep.c   ****               }
 2240              		.loc 1 869 17 is_stmt 1 view .LVU801
 869:Src/aspep.c   ****               }
 2241              		.loc 1 869 41 is_stmt 0 view .LVU802
 2242 0070 0123     		movs	r3, #1
 2243 0072 84F86530 		strb	r3, [r4, #101]
 2244              		.loc 1 917 1 view .LVU803
 2245 0076 38BD     		pop	{r3, r4, r5, pc}
 2246              	.LVL178:
 2247              	.L118:
 896:Src/aspep.c   ****         }
 2248              		.loc 1 896 11 is_stmt 1 view .LVU804
 896:Src/aspep.c   ****         }
 2249              		.loc 1 896 34 is_stmt 0 view .LVU805
 2250 0078 0423     		movs	r3, #4
 2251 007a 80F86230 		strb	r3, [r0, #98]
 2252              		.loc 1 917 1 view .LVU806
 2253 007e 38BD     		pop	{r3, r4, r5, pc}
 2254              	.L120:
 881:Src/aspep.c   ****               /* The receiver is not reconfigure right now on purpose to avoid race condition when 
 2255              		.loc 1 881 15 is_stmt 1 view .LVU807
 881:Src/aspep.c   ****               /* The receiver is not reconfigure right now on purpose to avoid race condition when 
 2256              		.loc 1 881 43 is_stmt 0 view .LVU808
 2257 0080 0123     		movs	r3, #1
 2258 0082 80F86130 		strb	r3, [r0, #97]
 884:Src/aspep.c   ****             }
 2259              		.loc 1 884 15 is_stmt 1 view .LVU809
 2260              		.loc 1 917 1 is_stmt 0 view .LVU810
 2261 0086 38BD     		pop	{r3, r4, r5, pc}
 2262              	.L119:
 889:Src/aspep.c   ****               break;
 2263              		.loc 1 889 15 is_stmt 1 view .LVU811
 889:Src/aspep.c   ****               break;
 2264              		.loc 1 889 38 is_stmt 0 view .LVU812
 2265 0088 0123     		movs	r3, #1
 2266 008a 80F86230 		strb	r3, [r0, #98]
 890:Src/aspep.c   ****             }
 2267              		.loc 1 890 15 is_stmt 1 view .LVU813
 2268              		.loc 1 917 1 is_stmt 0 view .LVU814
 2269 008e 38BD     		pop	{r3, r4, r5, pc}
 2270              	.L122:
 873:Src/aspep.c   ****               }
 2271              		.loc 1 873 17 is_stmt 1 view .LVU815
 873:Src/aspep.c   ****               }
 2272              		.loc 1 873 40 is_stmt 0 view .LVU816
 2273 0090 0223     		movs	r3, #2
 2274 0092 80F86230 		strb	r3, [r0, #98]
 2275              		.loc 1 917 1 view .LVU817
 2276 0096 38BD     		pop	{r3, r4, r5, pc}
 2277              	.L125:
ARM GAS  /tmp/ccJS0l1g.s 			page 73


 2278              		.align	2
 2279              	.L124:
 2280 0098 00000000 		.word	.LANCHOR0
 2281              		.cfi_endproc
 2282              	.LFE1449:
 2284              		.section	.text.ASPEP_HWReset,"ax",%progbits
 2285              		.align	1
 2286              		.p2align 2,,3
 2287              		.global	ASPEP_HWReset
 2288              		.syntax unified
 2289              		.thumb
 2290              		.thumb_func
 2291              		.fpu fpv4-sp-d16
 2293              	ASPEP_HWReset:
 2294              	.LVL179:
 2295              	.LFB1450:
 918:Src/aspep.c   **** 
 919:Src/aspep.c   **** /**
 920:Src/aspep.c   ****   * @brief  Resets DMA after debugger has stopped the MCU.
 921:Src/aspep.c   ****   *
 922:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 923:Src/aspep.c   ****   */
 924:Src/aspep.c   **** void ASPEP_HWReset(ASPEP_Handle_t *pHandle)
 925:Src/aspep.c   **** {
 2296              		.loc 1 925 1 is_stmt 1 view -0
 2297              		.cfi_startproc
 2298              		@ args = 0, pretend = 0, frame = 0
 2299              		@ frame_needed = 0, uses_anonymous_args = 0
 2300              		@ link register save eliminated.
 926:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 927:Src/aspep.c   ****   if (NULL == pHandle)
 928:Src/aspep.c   ****   {
 929:Src/aspep.c   ****     /* Nothing to do */
 930:Src/aspep.c   ****   }
 931:Src/aspep.c   ****   else
 932:Src/aspep.c   ****   {
 933:Src/aspep.c   **** #endif
 934:Src/aspep.c   ****     /* We must reset the RX state machine to be sure to not be in Waiting packet state */
 935:Src/aspep.c   ****     /* Otherwise the arrival of a new packet will trigger a NewPacketAvailable despite */
 936:Src/aspep.c   ****     /* the fact that bytes have been lost because of overrun (debugger paused for instance) */
 937:Src/aspep.c   ****     pHandle->ASPEP_TL_State = WAITING_PACKET;
 2301              		.loc 1 937 5 view .LVU819
 925:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 2302              		.loc 1 925 1 is_stmt 0 view .LVU820
 2303 0000 0146     		mov	r1, r0
 2304              		.loc 1 937 29 view .LVU821
 2305 0002 0023     		movs	r3, #0
 2306 0004 80F86530 		strb	r3, [r0, #101]
 938:Src/aspep.c   ****     pHandle->fASPEP_cfg_recept(pHandle->ASPEPIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 2307              		.loc 1 938 5 is_stmt 1 view .LVU822
 2308 0008 1C31     		adds	r1, r1, #28
 2309 000a 436D     		ldr	r3, [r0, #84]
 2310 000c 4069     		ldr	r0, [r0, #20]
 2311              	.LVL180:
 2312              		.loc 1 938 5 is_stmt 0 view .LVU823
 2313 000e 0422     		movs	r2, #4
 2314 0010 1847     		bx	r3	@ indirect register sibling call
ARM GAS  /tmp/ccJS0l1g.s 			page 74


 2315              	.LVL181:
 2316              		.loc 1 938 5 view .LVU824
 2317              		.cfi_endproc
 2318              	.LFE1450:
 2320 0012 00BF     		.section	.rodata.CRC4_Lookup4,"a"
 2321              		.align	2
 2322              		.set	.LANCHOR1,. + 0
 2325              	CRC4_Lookup4:
 2326 0000 00       		.byte	0
 2327 0001 07       		.byte	7
 2328 0002 0E       		.byte	14
 2329 0003 09       		.byte	9
 2330 0004 0B       		.byte	11
 2331 0005 0C       		.byte	12
 2332 0006 05       		.byte	5
 2333 0007 02       		.byte	2
 2334 0008 01       		.byte	1
 2335 0009 06       		.byte	6
 2336 000a 0F       		.byte	15
 2337 000b 08       		.byte	8
 2338 000c 0A       		.byte	10
 2339 000d 0D       		.byte	13
 2340 000e 04       		.byte	4
 2341 000f 03       		.byte	3
 2342              		.section	.rodata.CRC4_Lookup8,"a"
 2343              		.align	2
 2344              		.set	.LANCHOR0,. + 0
 2347              	CRC4_Lookup8:
 2348 0000 00       		.byte	0
 2349 0001 02       		.byte	2
 2350 0002 04       		.byte	4
 2351 0003 06       		.byte	6
 2352 0004 08       		.byte	8
 2353 0005 0A       		.byte	10
 2354 0006 0C       		.byte	12
 2355 0007 0E       		.byte	14
 2356 0008 07       		.byte	7
 2357 0009 05       		.byte	5
 2358 000a 03       		.byte	3
 2359 000b 01       		.byte	1
 2360 000c 0F       		.byte	15
 2361 000d 0D       		.byte	13
 2362 000e 0B       		.byte	11
 2363 000f 09       		.byte	9
 2364 0010 07       		.byte	7
 2365 0011 05       		.byte	5
 2366 0012 03       		.byte	3
 2367 0013 01       		.byte	1
 2368 0014 0F       		.byte	15
 2369 0015 0D       		.byte	13
 2370 0016 0B       		.byte	11
 2371 0017 09       		.byte	9
 2372 0018 00       		.byte	0
 2373 0019 02       		.byte	2
 2374 001a 04       		.byte	4
 2375 001b 06       		.byte	6
 2376 001c 08       		.byte	8
ARM GAS  /tmp/ccJS0l1g.s 			page 75


 2377 001d 0A       		.byte	10
 2378 001e 0C       		.byte	12
 2379 001f 0E       		.byte	14
 2380 0020 0E       		.byte	14
 2381 0021 0C       		.byte	12
 2382 0022 0A       		.byte	10
 2383 0023 08       		.byte	8
 2384 0024 06       		.byte	6
 2385 0025 04       		.byte	4
 2386 0026 02       		.byte	2
 2387 0027 00       		.byte	0
 2388 0028 09       		.byte	9
 2389 0029 0B       		.byte	11
 2390 002a 0D       		.byte	13
 2391 002b 0F       		.byte	15
 2392 002c 01       		.byte	1
 2393 002d 03       		.byte	3
 2394 002e 05       		.byte	5
 2395 002f 07       		.byte	7
 2396 0030 09       		.byte	9
 2397 0031 0B       		.byte	11
 2398 0032 0D       		.byte	13
 2399 0033 0F       		.byte	15
 2400 0034 01       		.byte	1
 2401 0035 03       		.byte	3
 2402 0036 05       		.byte	5
 2403 0037 07       		.byte	7
 2404 0038 0E       		.byte	14
 2405 0039 0C       		.byte	12
 2406 003a 0A       		.byte	10
 2407 003b 08       		.byte	8
 2408 003c 06       		.byte	6
 2409 003d 04       		.byte	4
 2410 003e 02       		.byte	2
 2411 003f 00       		.byte	0
 2412 0040 0B       		.byte	11
 2413 0041 09       		.byte	9
 2414 0042 0F       		.byte	15
 2415 0043 0D       		.byte	13
 2416 0044 03       		.byte	3
 2417 0045 01       		.byte	1
 2418 0046 07       		.byte	7
 2419 0047 05       		.byte	5
 2420 0048 0C       		.byte	12
 2421 0049 0E       		.byte	14
 2422 004a 08       		.byte	8
 2423 004b 0A       		.byte	10
 2424 004c 04       		.byte	4
 2425 004d 06       		.byte	6
 2426 004e 00       		.byte	0
 2427 004f 02       		.byte	2
 2428 0050 0C       		.byte	12
 2429 0051 0E       		.byte	14
 2430 0052 08       		.byte	8
 2431 0053 0A       		.byte	10
 2432 0054 04       		.byte	4
 2433 0055 06       		.byte	6
ARM GAS  /tmp/ccJS0l1g.s 			page 76


 2434 0056 00       		.byte	0
 2435 0057 02       		.byte	2
 2436 0058 0B       		.byte	11
 2437 0059 09       		.byte	9
 2438 005a 0F       		.byte	15
 2439 005b 0D       		.byte	13
 2440 005c 03       		.byte	3
 2441 005d 01       		.byte	1
 2442 005e 07       		.byte	7
 2443 005f 05       		.byte	5
 2444 0060 05       		.byte	5
 2445 0061 07       		.byte	7
 2446 0062 01       		.byte	1
 2447 0063 03       		.byte	3
 2448 0064 0D       		.byte	13
 2449 0065 0F       		.byte	15
 2450 0066 09       		.byte	9
 2451 0067 0B       		.byte	11
 2452 0068 02       		.byte	2
 2453 0069 00       		.byte	0
 2454 006a 06       		.byte	6
 2455 006b 04       		.byte	4
 2456 006c 0A       		.byte	10
 2457 006d 08       		.byte	8
 2458 006e 0E       		.byte	14
 2459 006f 0C       		.byte	12
 2460 0070 02       		.byte	2
 2461 0071 00       		.byte	0
 2462 0072 06       		.byte	6
 2463 0073 04       		.byte	4
 2464 0074 0A       		.byte	10
 2465 0075 08       		.byte	8
 2466 0076 0E       		.byte	14
 2467 0077 0C       		.byte	12
 2468 0078 05       		.byte	5
 2469 0079 07       		.byte	7
 2470 007a 01       		.byte	1
 2471 007b 03       		.byte	3
 2472 007c 0D       		.byte	13
 2473 007d 0F       		.byte	15
 2474 007e 09       		.byte	9
 2475 007f 0B       		.byte	11
 2476 0080 01       		.byte	1
 2477 0081 03       		.byte	3
 2478 0082 05       		.byte	5
 2479 0083 07       		.byte	7
 2480 0084 09       		.byte	9
 2481 0085 0B       		.byte	11
 2482 0086 0D       		.byte	13
 2483 0087 0F       		.byte	15
 2484 0088 06       		.byte	6
 2485 0089 04       		.byte	4
 2486 008a 02       		.byte	2
 2487 008b 00       		.byte	0
 2488 008c 0E       		.byte	14
 2489 008d 0C       		.byte	12
 2490 008e 0A       		.byte	10
ARM GAS  /tmp/ccJS0l1g.s 			page 77


 2491 008f 08       		.byte	8
 2492 0090 06       		.byte	6
 2493 0091 04       		.byte	4
 2494 0092 02       		.byte	2
 2495 0093 00       		.byte	0
 2496 0094 0E       		.byte	14
 2497 0095 0C       		.byte	12
 2498 0096 0A       		.byte	10
 2499 0097 08       		.byte	8
 2500 0098 01       		.byte	1
 2501 0099 03       		.byte	3
 2502 009a 05       		.byte	5
 2503 009b 07       		.byte	7
 2504 009c 09       		.byte	9
 2505 009d 0B       		.byte	11
 2506 009e 0D       		.byte	13
 2507 009f 0F       		.byte	15
 2508 00a0 0F       		.byte	15
 2509 00a1 0D       		.byte	13
 2510 00a2 0B       		.byte	11
 2511 00a3 09       		.byte	9
 2512 00a4 07       		.byte	7
 2513 00a5 05       		.byte	5
 2514 00a6 03       		.byte	3
 2515 00a7 01       		.byte	1
 2516 00a8 08       		.byte	8
 2517 00a9 0A       		.byte	10
 2518 00aa 0C       		.byte	12
 2519 00ab 0E       		.byte	14
 2520 00ac 00       		.byte	0
 2521 00ad 02       		.byte	2
 2522 00ae 04       		.byte	4
 2523 00af 06       		.byte	6
 2524 00b0 08       		.byte	8
 2525 00b1 0A       		.byte	10
 2526 00b2 0C       		.byte	12
 2527 00b3 0E       		.byte	14
 2528 00b4 00       		.byte	0
 2529 00b5 02       		.byte	2
 2530 00b6 04       		.byte	4
 2531 00b7 06       		.byte	6
 2532 00b8 0F       		.byte	15
 2533 00b9 0D       		.byte	13
 2534 00ba 0B       		.byte	11
 2535 00bb 09       		.byte	9
 2536 00bc 07       		.byte	7
 2537 00bd 05       		.byte	5
 2538 00be 03       		.byte	3
 2539 00bf 01       		.byte	1
 2540 00c0 0A       		.byte	10
 2541 00c1 08       		.byte	8
 2542 00c2 0E       		.byte	14
 2543 00c3 0C       		.byte	12
 2544 00c4 02       		.byte	2
 2545 00c5 00       		.byte	0
 2546 00c6 06       		.byte	6
 2547 00c7 04       		.byte	4
ARM GAS  /tmp/ccJS0l1g.s 			page 78


 2548 00c8 0D       		.byte	13
 2549 00c9 0F       		.byte	15
 2550 00ca 09       		.byte	9
 2551 00cb 0B       		.byte	11
 2552 00cc 05       		.byte	5
 2553 00cd 07       		.byte	7
 2554 00ce 01       		.byte	1
 2555 00cf 03       		.byte	3
 2556 00d0 0D       		.byte	13
 2557 00d1 0F       		.byte	15
 2558 00d2 09       		.byte	9
 2559 00d3 0B       		.byte	11
 2560 00d4 05       		.byte	5
 2561 00d5 07       		.byte	7
 2562 00d6 01       		.byte	1
 2563 00d7 03       		.byte	3
 2564 00d8 0A       		.byte	10
 2565 00d9 08       		.byte	8
 2566 00da 0E       		.byte	14
 2567 00db 0C       		.byte	12
 2568 00dc 02       		.byte	2
 2569 00dd 00       		.byte	0
 2570 00de 06       		.byte	6
 2571 00df 04       		.byte	4
 2572 00e0 04       		.byte	4
 2573 00e1 06       		.byte	6
 2574 00e2 00       		.byte	0
 2575 00e3 02       		.byte	2
 2576 00e4 0C       		.byte	12
 2577 00e5 0E       		.byte	14
 2578 00e6 08       		.byte	8
 2579 00e7 0A       		.byte	10
 2580 00e8 03       		.byte	3
 2581 00e9 01       		.byte	1
 2582 00ea 07       		.byte	7
 2583 00eb 05       		.byte	5
 2584 00ec 0B       		.byte	11
 2585 00ed 09       		.byte	9
 2586 00ee 0F       		.byte	15
 2587 00ef 0D       		.byte	13
 2588 00f0 03       		.byte	3
 2589 00f1 01       		.byte	1
 2590 00f2 07       		.byte	7
 2591 00f3 05       		.byte	5
 2592 00f4 0B       		.byte	11
 2593 00f5 09       		.byte	9
 2594 00f6 0F       		.byte	15
 2595 00f7 0D       		.byte	13
 2596 00f8 04       		.byte	4
 2597 00f9 06       		.byte	6
 2598 00fa 00       		.byte	0
 2599 00fb 02       		.byte	2
 2600 00fc 0C       		.byte	12
 2601 00fd 0E       		.byte	14
 2602 00fe 08       		.byte	8
 2603 00ff 0A       		.byte	10
 2604              		.text
ARM GAS  /tmp/ccJS0l1g.s 			page 79


 2605              	.Letext0:
 2606              		.file 3 "/usr/lib/gcc/arm-none-eabi/8.3.1/include/stdint.h"
 2607              		.file 4 "Drivers/CMSIS/Include/core_cm4.h"
 2608              		.file 5 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/system_stm32g4xx.h"
 2609              		.file 6 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_def.h"
 2610              		.file 7 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_flash.h"
 2611              		.file 8 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_uart.h"
 2612              		.file 9 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal.h"
 2613              		.file 10 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_tim.h"
 2614              		.file 11 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_usart.h"
 2615              		.file 12 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_dma.h"
 2616              		.file 13 "MCSDK_v6.3.0-Full/MotorControl/MCSDK/MCLib/Any/Inc/mcptl.h"
 2617              		.file 14 "Inc/aspep.h"
ARM GAS  /tmp/ccJS0l1g.s 			page 80


DEFINED SYMBOLS
                            *ABS*:0000000000000000 aspep.c
     /tmp/ccJS0l1g.s:18     .text.ASPEP_start:0000000000000000 $t
     /tmp/ccJS0l1g.s:27     .text.ASPEP_start:0000000000000000 ASPEP_start
     /tmp/ccJS0l1g.s:80     .text.ASPEP_sendBeacon:0000000000000000 $t
     /tmp/ccJS0l1g.s:88     .text.ASPEP_sendBeacon:0000000000000000 ASPEP_sendBeacon
     /tmp/ccJS0l1g.s:316    .text.ASPEP_sendBeacon:0000000000000084 $d
     /tmp/ccJS0l1g.s:324    .text.ASPEP_sendPing:0000000000000000 $t
     /tmp/ccJS0l1g.s:332    .text.ASPEP_sendPing:0000000000000000 ASPEP_sendPing
     /tmp/ccJS0l1g.s:561    .text.ASPEP_sendPing:0000000000000084 $d
     /tmp/ccJS0l1g.s:569    .text.ASPEP_getBuffer:0000000000000000 $t
     /tmp/ccJS0l1g.s:577    .text.ASPEP_getBuffer:0000000000000000 ASPEP_getBuffer
     /tmp/ccJS0l1g.s:730    .text.ASPEP_sendPacket:0000000000000000 $t
     /tmp/ccJS0l1g.s:738    .text.ASPEP_sendPacket:0000000000000000 ASPEP_sendPacket
     /tmp/ccJS0l1g.s:1156   .text.ASPEP_sendPacket:0000000000000108 $d
     /tmp/ccJS0l1g.s:1164   .text.ASPEP_HWDataTransmittedIT:0000000000000000 $t
     /tmp/ccJS0l1g.s:1172   .text.ASPEP_HWDataTransmittedIT:0000000000000000 ASPEP_HWDataTransmittedIT
     /tmp/ccJS0l1g.s:1369   .text.ASPEP_RXframeProcess:0000000000000000 $t
     /tmp/ccJS0l1g.s:1377   .text.ASPEP_RXframeProcess:0000000000000000 ASPEP_RXframeProcess
     /tmp/ccJS0l1g.s:2111   .text.ASPEP_RXframeProcess:00000000000002a4 $d
     /tmp/ccJS0l1g.s:2119   .text.ASPEP_HWDataReceivedIT:0000000000000000 $t
     /tmp/ccJS0l1g.s:2127   .text.ASPEP_HWDataReceivedIT:0000000000000000 ASPEP_HWDataReceivedIT
     /tmp/ccJS0l1g.s:2280   .text.ASPEP_HWDataReceivedIT:0000000000000098 $d
     /tmp/ccJS0l1g.s:2285   .text.ASPEP_HWReset:0000000000000000 $t
     /tmp/ccJS0l1g.s:2293   .text.ASPEP_HWReset:0000000000000000 ASPEP_HWReset
     /tmp/ccJS0l1g.s:2321   .rodata.CRC4_Lookup4:0000000000000000 $d
     /tmp/ccJS0l1g.s:2325   .rodata.CRC4_Lookup4:0000000000000000 CRC4_Lookup4
     /tmp/ccJS0l1g.s:2343   .rodata.CRC4_Lookup8:0000000000000000 $d
     /tmp/ccJS0l1g.s:2347   .rodata.CRC4_Lookup8:0000000000000000 CRC4_Lookup8

NO UNDEFINED SYMBOLS
